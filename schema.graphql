type Query {
  administrators(options: AdministratorListOptions): AdministratorList!
  administrator(id: ID!): Administrator
  activeAdministrator: Administrator

  """Get a list of Assets"""
  assets(options: AssetListOptions): AssetList!

  """Get a single Asset by id"""
  asset(id: ID!): Asset
  me: CurrentUser
  channels(options: ChannelListOptions): ChannelList!
  channel(id: ID!): Channel
  activeChannel: Channel!
  collections(options: CollectionListOptions): CollectionList!

  """
  Get a Collection either by id or slug. If neither id nor slug is specified, an error will result.
  """
  collection(id: ID, slug: String): Collection
  collectionFilters: [ConfigurableOperationDefinition!]!

  """Used for real-time previews of the contents of a Collection"""
  previewCollectionVariants(input: PreviewCollectionVariantsInput!, options: ProductVariantListOptions): ProductVariantList!
  countries(options: CountryListOptions): CountryList!
  country(id: ID!): Country
  customerGroups(options: CustomerGroupListOptions): CustomerGroupList!
  customerGroup(id: ID!): CustomerGroup
  customers(options: CustomerListOptions): CustomerList!
  customer(id: ID!): Customer

  """Returns all configured EntityDuplicators."""
  entityDuplicators: [EntityDuplicatorDefinition!]!
  facets(options: FacetListOptions): FacetList!
  facet(id: ID!): Facet
  facetValues(options: FacetValueListOptions): FacetValueList!
  facetValue(id: ID!): FacetValue
  globalSettings: GlobalSettings!
  job(jobId: ID!): Job
  jobs(options: JobListOptions): JobList!
  jobsById(jobIds: [ID!]!): [Job!]!
  jobQueues: [JobQueue!]!
  jobBufferSize(bufferIds: [String!]): [JobBufferSize!]!
  order(id: ID!): Order
  orders(options: OrderListOptions): OrderList!

  """Returns a list of eligible shipping methods for the draft Order"""
  eligibleShippingMethodsForDraftOrder(orderId: ID!): [ShippingMethodQuote!]!
  paymentMethods(options: PaymentMethodListOptions): PaymentMethodList!
  paymentMethod(id: ID!): PaymentMethod
  paymentMethodEligibilityCheckers: [ConfigurableOperationDefinition!]!
  paymentMethodHandlers: [ConfigurableOperationDefinition!]!
  productOptionGroups(filterTerm: String): [ProductOptionGroup!]!
  productOptionGroup(id: ID!): ProductOptionGroup
  productOptions(options: ProductOptionListOptions, groupId: ID): ProductOptionList!
  productOption(id: ID!): ProductOption
  search(input: SearchInput!): SearchResponse!
  pendingSearchIndexUpdates: Int!

  """List Products"""
  products(options: ProductListOptions): ProductList!

  """
  Get a Product either by id or slug. If neither id nor slug is specified, an error will result.
  """
  product(id: ID, slug: String): Product

  """List ProductVariants either all or for the specific product."""
  productVariants(options: ProductVariantListOptions, productId: ID): ProductVariantList!

  """Get a ProductVariant by id"""
  productVariant(id: ID!): ProductVariant
  promotion(id: ID!): Promotion
  promotions(options: PromotionListOptions): PromotionList!
  promotionConditions: [ConfigurableOperationDefinition!]!
  promotionActions: [ConfigurableOperationDefinition!]!
  provinces(options: ProvinceListOptions): ProvinceList!
  province(id: ID!): Province
  roles(options: RoleListOptions): RoleList!
  role(id: ID!): Role
  scheduledTasks: [ScheduledTask!]!
  sellers(options: SellerListOptions): SellerList!
  seller(id: ID!): Seller

  """
  Get value for a specific key (automatically scoped based on field configuration)
  """
  getSettingsStoreValue(key: String!): JSON

  """Get multiple key-value pairs (each automatically scoped)"""
  getSettingsStoreValues(keys: [String!]!): JSON
  shippingMethods(options: ShippingMethodListOptions): ShippingMethodList!
  shippingMethod(id: ID!): ShippingMethod
  shippingEligibilityCheckers: [ConfigurableOperationDefinition!]!
  shippingCalculators: [ConfigurableOperationDefinition!]!
  fulfillmentHandlers: [ConfigurableOperationDefinition!]!
  testShippingMethod(input: TestShippingMethodInput!): TestShippingMethodResult!
  testEligibleShippingMethods(input: TestEligibleShippingMethodsInput!): [ShippingMethodQuote!]!

  """Generate slug for entity"""
  slugForEntity(input: SlugForEntityInput!): String!
  stockLocation(id: ID!): StockLocation
  stockLocations(options: StockLocationListOptions): StockLocationList!
  tag(id: ID!): Tag!
  tags(options: TagListOptions): TagList!
  taxCategories(options: TaxCategoryListOptions): TaxCategoryList!
  taxCategory(id: ID!): TaxCategory
  taxRates(options: TaxRateListOptions): TaxRateList!
  taxRate(id: ID!): TaxRate
  zones(options: ZoneListOptions): ZoneList!
  zone(id: ID!): Zone

  """Get metrics for the given date range and metric types."""
  dashboardMetricSummary(input: DashboardMetricSummaryInput): [DashboardMetricSummary!]!
}

type Mutation {
  """Create a new Administrator"""
  createAdministrator(input: CreateAdministratorInput!): Administrator!

  """Update an existing Administrator"""
  updateAdministrator(input: UpdateAdministratorInput!): Administrator!

  """Update the active (currently logged-in) Administrator"""
  updateActiveAdministrator(input: UpdateActiveAdministratorInput!): Administrator!

  """Delete an Administrator"""
  deleteAdministrator(id: ID!): DeletionResponse!

  """Delete multiple Administrators"""
  deleteAdministrators(ids: [ID!]!): [DeletionResponse!]!

  """Assign a Role to an Administrator"""
  assignRoleToAdministrator(administratorId: ID!, roleId: ID!): Administrator!

  """Create a new Asset"""
  createAssets(input: [CreateAssetInput!]!): [CreateAssetResult!]!

  """Update an existing Asset"""
  updateAsset(input: UpdateAssetInput!): Asset!

  """Delete an Asset"""
  deleteAsset(input: DeleteAssetInput!): DeletionResponse!

  """Delete multiple Assets"""
  deleteAssets(input: DeleteAssetsInput!): DeletionResponse!

  """Assign assets to channel"""
  assignAssetsToChannel(input: AssignAssetsToChannelInput!): [Asset!]!

  """
  Authenticates the user using the native authentication strategy. This mutation is an alias for authenticate({ native: { ... }})
  
  The `rememberMe` option applies when using cookie-based sessions, and if `true` it will set the maxAge of the session cookie
  to 1 year.
  """
  login(username: String!, password: String!, rememberMe: Boolean): NativeAuthenticationResult!

  """Authenticates the user using a named authentication strategy"""
  authenticate(input: AuthenticationInput!, rememberMe: Boolean): AuthenticationResult!
  logout: Success!

  """Create a new Channel"""
  createChannel(input: CreateChannelInput!): CreateChannelResult!

  """Update an existing Channel"""
  updateChannel(input: UpdateChannelInput!): UpdateChannelResult!

  """Delete a Channel"""
  deleteChannel(id: ID!): DeletionResponse!

  """Delete multiple Channels"""
  deleteChannels(ids: [ID!]!): [DeletionResponse!]!

  """Create a new Collection"""
  createCollection(input: CreateCollectionInput!): Collection!

  """Update an existing Collection"""
  updateCollection(input: UpdateCollectionInput!): Collection!

  """Delete a Collection and all of its descendants"""
  deleteCollection(id: ID!): DeletionResponse!

  """Delete multiple Collections and all of their descendants"""
  deleteCollections(ids: [ID!]!): [DeletionResponse!]!

  """Move a Collection to a different parent or index"""
  moveCollection(input: MoveCollectionInput!): Collection!

  """Assigns Collections to the specified Channel"""
  assignCollectionsToChannel(input: AssignCollectionsToChannelInput!): [Collection!]!

  """Removes Collections from the specified Channel"""
  removeCollectionsFromChannel(input: RemoveCollectionsFromChannelInput!): [Collection!]!

  """Create a new Country"""
  createCountry(input: CreateCountryInput!): Country!

  """Update an existing Country"""
  updateCountry(input: UpdateCountryInput!): Country!

  """Delete a Country"""
  deleteCountry(id: ID!): DeletionResponse!

  """Delete multiple Countries"""
  deleteCountries(ids: [ID!]!): [DeletionResponse!]!

  """Create a new CustomerGroup"""
  createCustomerGroup(input: CreateCustomerGroupInput!): CustomerGroup!

  """Update an existing CustomerGroup"""
  updateCustomerGroup(input: UpdateCustomerGroupInput!): CustomerGroup!

  """Delete a CustomerGroup"""
  deleteCustomerGroup(id: ID!): DeletionResponse!

  """Delete multiple CustomerGroups"""
  deleteCustomerGroups(ids: [ID!]!): [DeletionResponse!]!

  """Add Customers to a CustomerGroup"""
  addCustomersToGroup(customerGroupId: ID!, customerIds: [ID!]!): CustomerGroup!

  """Remove Customers from a CustomerGroup"""
  removeCustomersFromGroup(customerGroupId: ID!, customerIds: [ID!]!): CustomerGroup!

  """
  Create a new Customer. If a password is provided, a new User will also be created an linked to the Customer.
  """
  createCustomer(input: CreateCustomerInput!, password: String): CreateCustomerResult!

  """Update an existing Customer"""
  updateCustomer(input: UpdateCustomerInput!): UpdateCustomerResult!

  """Delete a Customer"""
  deleteCustomer(id: ID!): DeletionResponse!

  """Deletes Customers"""
  deleteCustomers(ids: [ID!]!): [DeletionResponse!]!

  """
  Create a new Address and associate it with the Customer specified by customerId
  """
  createCustomerAddress(customerId: ID!, input: CreateAddressInput!): Address!

  """Update an existing Address"""
  updateCustomerAddress(input: UpdateAddressInput!): Address!

  """Update an existing Address"""
  deleteCustomerAddress(id: ID!): Success!
  addNoteToCustomer(input: AddNoteToCustomerInput!): Customer!
  updateCustomerNote(input: UpdateCustomerNoteInput!): HistoryEntry!
  deleteCustomerNote(id: ID!): DeletionResponse!

  """
  Duplicate an existing entity using a specific EntityDuplicator.
  Since v2.2.0.
  """
  duplicateEntity(input: DuplicateEntityInput!): DuplicateEntityResult!

  """Create a new Facet"""
  createFacet(input: CreateFacetInput!): Facet!

  """Update an existing Facet"""
  updateFacet(input: UpdateFacetInput!): Facet!

  """Delete an existing Facet"""
  deleteFacet(id: ID!, force: Boolean): DeletionResponse!

  """Delete multiple existing Facets"""
  deleteFacets(ids: [ID!]!, force: Boolean): [DeletionResponse!]!

  """Create one or more FacetValues"""
  createFacetValues(input: [CreateFacetValueInput!]!): [FacetValue!]!

  """Create a single FacetValue"""
  createFacetValue(input: CreateFacetValueInput!): FacetValue!

  """Update one or more FacetValues"""
  updateFacetValues(input: [UpdateFacetValueInput!]!): [FacetValue!]!

  """Update a single FacetValue"""
  updateFacetValue(input: UpdateFacetValueInput!): FacetValue!

  """Delete one or more FacetValues"""
  deleteFacetValues(ids: [ID!]!, force: Boolean): [DeletionResponse!]!

  """Assigns Facets to the specified Channel"""
  assignFacetsToChannel(input: AssignFacetsToChannelInput!): [Facet!]!

  """Removes Facets from the specified Channel"""
  removeFacetsFromChannel(input: RemoveFacetsFromChannelInput!): [RemoveFacetFromChannelResult!]!
  updateGlobalSettings(input: UpdateGlobalSettingsInput!): UpdateGlobalSettingsResult!
  importProducts(csvFile: Upload!): ImportInfo

  """
  Remove all settled jobs in the given queues older than the given date. Returns the number of jobs deleted.
  """
  removeSettledJobs(queueNames: [String!], olderThan: DateTime): Int!
  cancelJob(jobId: ID!): Job!
  flushBufferedJobs(bufferIds: [String!]): Success!
  settlePayment(id: ID!): SettlePaymentResult!
  cancelPayment(id: ID!): CancelPaymentResult!
  addFulfillmentToOrder(input: FulfillOrderInput!): AddFulfillmentToOrderResult!
  cancelOrder(input: CancelOrderInput!): CancelOrderResult!
  refundOrder(input: RefundOrderInput!): RefundOrderResult!
  settleRefund(input: SettleRefundInput!): SettleRefundResult!
  addNoteToOrder(input: AddNoteToOrderInput!): Order!
  updateOrderNote(input: UpdateOrderNoteInput!): HistoryEntry!
  deleteOrderNote(id: ID!): DeletionResponse!
  transitionOrderToState(id: ID!, state: String!): TransitionOrderToStateResult
  transitionFulfillmentToState(id: ID!, state: String!): TransitionFulfillmentToStateResult!
  transitionPaymentToState(id: ID!, state: String!): TransitionPaymentToStateResult!
  setOrderCustomFields(input: UpdateOrderInput!): Order

  """
  Allows a different Customer to be assigned to an Order. Added in v2.2.0.
  """
  setOrderCustomer(input: SetOrderCustomerInput!): Order

  """
  Allows an Order to be modified after it has been completed by the Customer. The Order must first
  be in the `Modifying` state.
  """
  modifyOrder(input: ModifyOrderInput!): ModifyOrderResult!

  """
  Used to manually create a new Payment against an Order.
  This can be used by an Administrator when an Order is in the ArrangingPayment state.
  
  It is also used when a completed Order
  has been modified (using `modifyOrder`) and the price has increased. The extra payment
  can then be manually arranged by the administrator, and the details used to create a new
  Payment.
  """
  addManualPaymentToOrder(input: ManualPaymentInput!): AddManualPaymentToOrderResult!

  """Creates a draft Order"""
  createDraftOrder: Order!

  """Deletes a draft Order"""
  deleteDraftOrder(orderId: ID!): DeletionResponse!

  """Adds an item to the draft Order."""
  addItemToDraftOrder(orderId: ID!, input: AddItemToDraftOrderInput!): UpdateOrderItemsResult!

  """
  Adjusts a draft OrderLine. If custom fields are defined on the OrderLine entity, a third argument 'customFields' of type `OrderLineCustomFieldsInput` will be available.
  """
  adjustDraftOrderLine(orderId: ID!, input: AdjustDraftOrderLineInput!): UpdateOrderItemsResult!

  """Remove an OrderLine from the draft Order"""
  removeDraftOrderLine(orderId: ID!, orderLineId: ID!): RemoveOrderItemsResult!
  setCustomerForDraftOrder(orderId: ID!, customerId: ID, input: CreateCustomerInput): SetCustomerForDraftOrderResult!

  """Sets the shipping address for a draft Order"""
  setDraftOrderShippingAddress(orderId: ID!, input: CreateAddressInput!): Order!

  """Sets the billing address for a draft Order"""
  setDraftOrderBillingAddress(orderId: ID!, input: CreateAddressInput!): Order!

  """Unsets the shipping address for a draft Order"""
  unsetDraftOrderShippingAddress(orderId: ID!): Order!

  """Unsets the billing address for a draft Order"""
  unsetDraftOrderBillingAddress(orderId: ID!): Order!

  """Allows any custom fields to be set for the active order"""
  setDraftOrderCustomFields(orderId: ID!, input: UpdateOrderInput!): Order!

  """Applies the given coupon code to the draft Order"""
  applyCouponCodeToDraftOrder(orderId: ID!, couponCode: String!): ApplyCouponCodeResult!

  """Removes the given coupon code from the draft Order"""
  removeCouponCodeFromDraftOrder(orderId: ID!, couponCode: String!): Order

  """
  Sets the shipping method by id, which can be obtained with the `eligibleShippingMethodsForDraftOrder` query
  """
  setDraftOrderShippingMethod(orderId: ID!, shippingMethodId: ID!): SetOrderShippingMethodResult!

  """Create existing PaymentMethod"""
  createPaymentMethod(input: CreatePaymentMethodInput!): PaymentMethod!

  """Update an existing PaymentMethod"""
  updatePaymentMethod(input: UpdatePaymentMethodInput!): PaymentMethod!

  """Delete a PaymentMethod"""
  deletePaymentMethod(id: ID!, force: Boolean): DeletionResponse!

  """Delete multiple PaymentMethods"""
  deletePaymentMethods(ids: [ID!]!, force: Boolean): [DeletionResponse!]!

  """Assigns PaymentMethods to the specified Channel"""
  assignPaymentMethodsToChannel(input: AssignPaymentMethodsToChannelInput!): [PaymentMethod!]!

  """Removes PaymentMethods from the specified Channel"""
  removePaymentMethodsFromChannel(input: RemovePaymentMethodsFromChannelInput!): [PaymentMethod!]!

  """Create a new ProductOptionGroup"""
  createProductOptionGroup(input: CreateProductOptionGroupInput!): ProductOptionGroup!

  """Update an existing ProductOptionGroup"""
  updateProductOptionGroup(input: UpdateProductOptionGroupInput!): ProductOptionGroup!

  """Create a new ProductOption within a ProductOptionGroup"""
  createProductOption(input: CreateProductOptionInput!): ProductOption!

  """Create a new ProductOption within a ProductOptionGroup"""
  updateProductOption(input: UpdateProductOptionInput!): ProductOption!

  """Delete a ProductOption"""
  deleteProductOption(id: ID!): DeletionResponse!
  reindex: Job!
  runPendingSearchIndexUpdates: Success!

  """Create a new Product"""
  createProduct(input: CreateProductInput!): Product!

  """Update an existing Product"""
  updateProduct(input: UpdateProductInput!): Product!

  """Update multiple existing Products"""
  updateProducts(input: [UpdateProductInput!]!): [Product!]!

  """Delete a Product"""
  deleteProduct(id: ID!): DeletionResponse!

  """Delete multiple Products"""
  deleteProducts(ids: [ID!]!): [DeletionResponse!]!

  """Add an OptionGroup to a Product"""
  addOptionGroupToProduct(productId: ID!, optionGroupId: ID!): Product!

  """
  Remove an OptionGroup from a Product. If the OptionGroup is in use by any ProductVariants
  the mutation will return a ProductOptionInUseError, and the OptionGroup will not be removed.
  Setting the `force` argument to `true` will override this and remove the OptionGroup anyway,
  as well as removing any of the group's options from the Product's ProductVariants.
  """
  removeOptionGroupFromProduct(productId: ID!, optionGroupId: ID!, force: Boolean): RemoveOptionGroupFromProductResult!

  """
  Create a set of ProductVariants based on the OptionGroups assigned to the given Product
  """
  createProductVariants(input: [CreateProductVariantInput!]!): [ProductVariant]!

  """Update existing ProductVariants"""
  updateProductVariants(input: [UpdateProductVariantInput!]!): [ProductVariant]!

  """Update an existing ProductVariant"""
  updateProductVariant(input: UpdateProductVariantInput!): ProductVariant!

  """Delete a ProductVariant"""
  deleteProductVariant(id: ID!): DeletionResponse!

  """Delete multiple ProductVariants"""
  deleteProductVariants(ids: [ID!]!): [DeletionResponse!]!

  """Assigns all ProductVariants of Product to the specified Channel"""
  assignProductsToChannel(input: AssignProductsToChannelInput!): [Product!]!

  """Removes all ProductVariants of Product from the specified Channel"""
  removeProductsFromChannel(input: RemoveProductsFromChannelInput!): [Product!]!

  """Assigns ProductVariants to the specified Channel"""
  assignProductVariantsToChannel(input: AssignProductVariantsToChannelInput!): [ProductVariant!]!

  """Removes ProductVariants from the specified Channel"""
  removeProductVariantsFromChannel(input: RemoveProductVariantsFromChannelInput!): [ProductVariant!]!
  createPromotion(input: CreatePromotionInput!): CreatePromotionResult!
  updatePromotion(input: UpdatePromotionInput!): UpdatePromotionResult!
  deletePromotion(id: ID!): DeletionResponse!
  deletePromotions(ids: [ID!]!): [DeletionResponse!]!

  """Assigns Promotions to the specified Channel"""
  assignPromotionsToChannel(input: AssignPromotionsToChannelInput!): [Promotion!]!

  """Removes Promotions from the specified Channel"""
  removePromotionsFromChannel(input: RemovePromotionsFromChannelInput!): [Promotion!]!

  """Create a new Province"""
  createProvince(input: CreateProvinceInput!): Province!

  """Update an existing Province"""
  updateProvince(input: UpdateProvinceInput!): Province!

  """Delete a Province"""
  deleteProvince(id: ID!): DeletionResponse!

  """Create a new Role"""
  createRole(input: CreateRoleInput!): Role!

  """Update an existing Role"""
  updateRole(input: UpdateRoleInput!): Role!

  """Delete an existing Role"""
  deleteRole(id: ID!): DeletionResponse!

  """Delete multiple Roles"""
  deleteRoles(ids: [ID!]!): [DeletionResponse!]!
  updateScheduledTask(input: UpdateScheduledTaskInput!): ScheduledTask!
  runScheduledTask(id: String!): Success!

  """Create a new Seller"""
  createSeller(input: CreateSellerInput!): Seller!

  """Update an existing Seller"""
  updateSeller(input: UpdateSellerInput!): Seller!

  """Delete a Seller"""
  deleteSeller(id: ID!): DeletionResponse!

  """Delete multiple Sellers"""
  deleteSellers(ids: [ID!]!): [DeletionResponse!]!

  """
  Set a single key-value pair (automatically scoped based on field configuration)
  """
  setSettingsStoreValue(input: SettingsStoreInput!): SetSettingsStoreValueResult!

  """
  Set multiple key-value pairs in a transaction (each automatically scoped)
  """
  setSettingsStoreValues(inputs: [SettingsStoreInput!]!): [SetSettingsStoreValueResult!]!

  """Create a new ShippingMethod"""
  createShippingMethod(input: CreateShippingMethodInput!): ShippingMethod!

  """Update an existing ShippingMethod"""
  updateShippingMethod(input: UpdateShippingMethodInput!): ShippingMethod!

  """Delete a ShippingMethod"""
  deleteShippingMethod(id: ID!): DeletionResponse!

  """Delete multiple ShippingMethods"""
  deleteShippingMethods(ids: [ID!]!): [DeletionResponse!]!

  """Assigns ShippingMethods to the specified Channel"""
  assignShippingMethodsToChannel(input: AssignShippingMethodsToChannelInput!): [ShippingMethod!]!

  """Removes ShippingMethods from the specified Channel"""
  removeShippingMethodsFromChannel(input: RemoveShippingMethodsFromChannelInput!): [ShippingMethod!]!
  createStockLocation(input: CreateStockLocationInput!): StockLocation!
  updateStockLocation(input: UpdateStockLocationInput!): StockLocation!
  deleteStockLocation(input: DeleteStockLocationInput!): DeletionResponse!
  deleteStockLocations(input: [DeleteStockLocationInput!]!): [DeletionResponse!]!

  """Assigns StockLocations to the specified Channel"""
  assignStockLocationsToChannel(input: AssignStockLocationsToChannelInput!): [StockLocation!]!

  """Removes StockLocations from the specified Channel"""
  removeStockLocationsFromChannel(input: RemoveStockLocationsFromChannelInput!): [StockLocation!]!

  """Create a new Tag"""
  createTag(input: CreateTagInput!): Tag!

  """Update an existing Tag"""
  updateTag(input: UpdateTagInput!): Tag!

  """Delete an existing Tag"""
  deleteTag(id: ID!): DeletionResponse!

  """Create a new TaxCategory"""
  createTaxCategory(input: CreateTaxCategoryInput!): TaxCategory!

  """Update an existing TaxCategory"""
  updateTaxCategory(input: UpdateTaxCategoryInput!): TaxCategory!

  """Deletes a TaxCategory"""
  deleteTaxCategory(id: ID!): DeletionResponse!

  """Deletes multiple TaxCategories"""
  deleteTaxCategories(ids: [ID!]!): [DeletionResponse!]!

  """Create a new TaxRate"""
  createTaxRate(input: CreateTaxRateInput!): TaxRate!

  """Update an existing TaxRate"""
  updateTaxRate(input: UpdateTaxRateInput!): TaxRate!

  """Delete a TaxRate"""
  deleteTaxRate(id: ID!): DeletionResponse!

  """Delete multiple TaxRates"""
  deleteTaxRates(ids: [ID!]!): [DeletionResponse!]!

  """Create a new Zone"""
  createZone(input: CreateZoneInput!): Zone!

  """Update an existing Zone"""
  updateZone(input: UpdateZoneInput!): Zone!

  """Delete a Zone"""
  deleteZone(id: ID!): DeletionResponse!

  """Delete a Zone"""
  deleteZones(ids: [ID!]!): [DeletionResponse!]!

  """Add members to a Zone"""
  addMembersToZone(zoneId: ID!, memberIds: [ID!]!): Zone!

  """Remove members from a Zone"""
  removeMembersFromZone(zoneId: ID!, memberIds: [ID!]!): Zone!
}

input AdministratorListOptions {
  """Skips the first n results, for use in pagination"""
  skip: Int

  """Takes n results, for use in pagination"""
  take: Int

  """Specifies which properties to sort the results by"""
  sort: AdministratorSortParameter

  """Allows the results to be filtered"""
  filter: AdministratorFilterParameter

  """
  Specifies whether multiple top-level "filter" fields should be combined with a logical AND or OR operation. Defaults to AND.
  """
  filterOperator: LogicalOperator
}

input CreateAdministratorInput {
  firstName: String!
  lastName: String!
  emailAddress: String!
  password: String!
  roleIds: [ID!]!
  customFields: JSON
}

input UpdateAdministratorInput {
  id: ID!
  firstName: String
  lastName: String
  emailAddress: String
  password: String
  roleIds: [ID!]
  customFields: JSON
}

input UpdateActiveAdministratorInput {
  firstName: String
  lastName: String
  emailAddress: String
  password: String
  customFields: JSON
}

type Administrator implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  firstName: String!
  lastName: String!
  emailAddress: String!
  user: User!
  customFields: JSON
}

type AdministratorList implements PaginatedList {
  items: [Administrator!]!
  totalItems: Int!
}

type MimeTypeError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
  fileName: String!
  mimeType: String!
}

union CreateAssetResult = Asset | MimeTypeError

input AssetListOptions {
  tags: [String!]
  tagsOperator: LogicalOperator

  """Skips the first n results, for use in pagination"""
  skip: Int

  """Takes n results, for use in pagination"""
  take: Int

  """Specifies which properties to sort the results by"""
  sort: AssetSortParameter

  """Allows the results to be filtered"""
  filter: AssetFilterParameter

  """
  Specifies whether multiple top-level "filter" fields should be combined with a logical AND or OR operation. Defaults to AND.
  """
  filterOperator: LogicalOperator
}

input CreateAssetInput {
  file: Upload!
  tags: [String!]
  customFields: JSON
}

input CoordinateInput {
  x: Float!
  y: Float!
}

input DeleteAssetInput {
  assetId: ID!
  force: Boolean
  deleteFromAllChannels: Boolean
}

input DeleteAssetsInput {
  assetIds: [ID!]!
  force: Boolean
  deleteFromAllChannels: Boolean
}

input UpdateAssetInput {
  id: ID!
  name: String
  focalPoint: CoordinateInput
  tags: [String!]
  customFields: JSON
}

input AssignAssetsToChannelInput {
  assetIds: [ID!]!
  channelId: ID!
}

input AuthenticationInput {
  native: NativeAuthInput
}

union NativeAuthenticationResult = CurrentUser | InvalidCredentialsError | NativeAuthStrategyError

union AuthenticationResult = CurrentUser | InvalidCredentialsError

type ChannelList implements PaginatedList {
  items: [Channel!]!
  totalItems: Int!
}

input ChannelListOptions {
  """Skips the first n results, for use in pagination"""
  skip: Int

  """Takes n results, for use in pagination"""
  take: Int

  """Specifies which properties to sort the results by"""
  sort: ChannelSortParameter

  """Allows the results to be filtered"""
  filter: ChannelFilterParameter

  """
  Specifies whether multiple top-level "filter" fields should be combined with a logical AND or OR operation. Defaults to AND.
  """
  filterOperator: LogicalOperator
}

input CreateChannelInput {
  code: String!
  token: String!
  defaultLanguageCode: LanguageCode!
  availableLanguageCodes: [LanguageCode!]
  pricesIncludeTax: Boolean!
  currencyCode: CurrencyCode @deprecated(reason: "Use defaultCurrencyCode instead")
  defaultCurrencyCode: CurrencyCode
  availableCurrencyCodes: [CurrencyCode!]
  trackInventory: Boolean
  outOfStockThreshold: Int
  defaultTaxZoneId: ID!
  defaultShippingZoneId: ID!
  sellerId: ID
  customFields: JSON
}

input UpdateChannelInput {
  id: ID!
  code: String
  token: String
  defaultLanguageCode: LanguageCode
  availableLanguageCodes: [LanguageCode!]
  pricesIncludeTax: Boolean
  currencyCode: CurrencyCode @deprecated(reason: "Use defaultCurrencyCode instead")
  defaultCurrencyCode: CurrencyCode
  availableCurrencyCodes: [CurrencyCode!]
  trackInventory: Boolean
  outOfStockThreshold: Int
  defaultTaxZoneId: ID
  defaultShippingZoneId: ID
  sellerId: ID
  customFields: JSON
}

"""
Returned if attempting to set a Channel's defaultLanguageCode to a language which is not enabled in GlobalSettings
"""
type LanguageNotAvailableError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
  languageCode: String!
}

union CreateChannelResult = Channel | LanguageNotAvailableError

union UpdateChannelResult = Channel | LanguageNotAvailableError

type Collection implements Node {
  isPrivate: Boolean!
  inheritFilters: Boolean!
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode
  name: String!
  slug: String!
  breadcrumbs: [CollectionBreadcrumb!]!
  position: Int!
  description: String!
  featuredAsset: Asset
  assets: [Asset!]!
  parent: Collection
  parentId: ID!
  children: [Collection!]
  filters: [ConfigurableOperation!]!
  translations: [CollectionTranslation!]!
  productVariants(options: ProductVariantListOptions): ProductVariantList!
  customFields: JSON
}

input CollectionListOptions {
  topLevelOnly: Boolean

  """Skips the first n results, for use in pagination"""
  skip: Int

  """Takes n results, for use in pagination"""
  take: Int

  """Specifies which properties to sort the results by"""
  sort: CollectionSortParameter

  """Allows the results to be filtered"""
  filter: CollectionFilterParameter

  """
  Specifies whether multiple top-level "filter" fields should be combined with a logical AND or OR operation. Defaults to AND.
  """
  filterOperator: LogicalOperator
}

input MoveCollectionInput {
  collectionId: ID!
  parentId: ID!
  index: Int!
}

input CreateCollectionTranslationInput {
  languageCode: LanguageCode!
  name: String!
  slug: String!
  description: String!
  customFields: JSON
}

input UpdateCollectionTranslationInput {
  id: ID
  languageCode: LanguageCode!
  name: String
  slug: String
  description: String
  customFields: JSON
}

input CreateCollectionInput {
  isPrivate: Boolean
  featuredAssetId: ID
  assetIds: [ID!]
  parentId: ID
  inheritFilters: Boolean
  filters: [ConfigurableOperationInput!]!
  translations: [CreateCollectionTranslationInput!]!
  customFields: JSON
}

input PreviewCollectionVariantsInput {
  parentId: ID
  inheritFilters: Boolean!
  filters: [ConfigurableOperationInput!]!
}

input UpdateCollectionInput {
  id: ID!
  isPrivate: Boolean
  featuredAssetId: ID
  parentId: ID
  assetIds: [ID!]
  inheritFilters: Boolean
  filters: [ConfigurableOperationInput!]
  translations: [UpdateCollectionTranslationInput!]
  customFields: JSON
}

input AssignCollectionsToChannelInput {
  collectionIds: [ID!]!
  channelId: ID!
}

input RemoveCollectionsFromChannelInput {
  collectionIds: [ID!]!
  channelId: ID!
}

input CountryTranslationInput {
  id: ID
  languageCode: LanguageCode!
  name: String
  customFields: JSON
}

input CreateCountryInput {
  code: String!
  translations: [CountryTranslationInput!]!
  enabled: Boolean!
  customFields: JSON
}

input UpdateCountryInput {
  id: ID!
  code: String
  translations: [CountryTranslationInput!]
  enabled: Boolean
  customFields: JSON
}

input CountryListOptions {
  """Skips the first n results, for use in pagination"""
  skip: Int

  """Takes n results, for use in pagination"""
  take: Int

  """Specifies which properties to sort the results by"""
  sort: CountrySortParameter

  """Allows the results to be filtered"""
  filter: CountryFilterParameter

  """
  Specifies whether multiple top-level "filter" fields should be combined with a logical AND or OR operation. Defaults to AND.
  """
  filterOperator: LogicalOperator
}

type Customer implements Node {
  groups: [CustomerGroup!]!
  history(options: HistoryEntryListOptions): HistoryEntryList!
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  title: String
  firstName: String!
  lastName: String!
  phoneNumber: String
  emailAddress: String!
  addresses: [Address!]
  orders(options: OrderListOptions): OrderList!
  user: User
  customFields: JSON
}

type CustomerGroupList implements PaginatedList {
  items: [CustomerGroup!]!
  totalItems: Int!
}

input CustomerGroupListOptions {
  """Skips the first n results, for use in pagination"""
  skip: Int

  """Takes n results, for use in pagination"""
  take: Int

  """Specifies which properties to sort the results by"""
  sort: CustomerGroupSortParameter

  """Allows the results to be filtered"""
  filter: CustomerGroupFilterParameter

  """
  Specifies whether multiple top-level "filter" fields should be combined with a logical AND or OR operation. Defaults to AND.
  """
  filterOperator: LogicalOperator
}

input CreateCustomerGroupInput {
  name: String!
  customerIds: [ID!]
  customFields: JSON
}

input UpdateCustomerGroupInput {
  id: ID!
  name: String
  customFields: JSON
}

input UpdateCustomerInput {
  id: ID!
  title: String
  firstName: String
  lastName: String
  phoneNumber: String
  emailAddress: String
  customFields: JSON
}

input CustomerFilterParameter {
  postalCode: StringOperators
  id: IDOperators
  createdAt: DateOperators
  updatedAt: DateOperators
  title: StringOperators
  firstName: StringOperators
  lastName: StringOperators
  phoneNumber: StringOperators
  emailAddress: StringOperators
  _and: [CustomerFilterParameter!]
  _or: [CustomerFilterParameter!]
}

input CustomerListOptions {
  """Skips the first n results, for use in pagination"""
  skip: Int

  """Takes n results, for use in pagination"""
  take: Int

  """Specifies which properties to sort the results by"""
  sort: CustomerSortParameter

  """Allows the results to be filtered"""
  filter: CustomerFilterParameter

  """
  Specifies whether multiple top-level "filter" fields should be combined with a logical AND or OR operation. Defaults to AND.
  """
  filterOperator: LogicalOperator
}

input AddNoteToCustomerInput {
  id: ID!
  note: String!
  isPublic: Boolean!
}

input UpdateCustomerNoteInput {
  noteId: ID!
  note: String!
}

union CreateCustomerResult = Customer | EmailAddressConflictError

union UpdateCustomerResult = Customer | EmailAddressConflictError

type EntityDuplicatorDefinition {
  code: String!
  args: [ConfigArgDefinition!]!
  description: String!
  forEntities: [String!]!
  requiresPermission: [Permission!]!
}

type DuplicateEntitySuccess {
  newEntityId: ID!
}

type DuplicateEntityError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
  duplicationError: String!
}

union DuplicateEntityResult = DuplicateEntitySuccess | DuplicateEntityError

input DuplicateEntityInput {
  entityName: String!
  entityId: ID!
  duplicatorInput: ConfigurableOperationInput!
}

type Facet implements Node {
  isPrivate: Boolean!
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  name: String!
  code: String!
  values: [FacetValue!]!

  """
  Returns a paginated, sortable, filterable list of the Facet's values. Added in v2.1.0.
  """
  valueList(options: FacetValueListOptions): FacetValueList!
  translations: [FacetTranslation!]!
  customFields: JSON
}

input FacetListOptions {
  """Skips the first n results, for use in pagination"""
  skip: Int

  """Takes n results, for use in pagination"""
  take: Int

  """Specifies which properties to sort the results by"""
  sort: FacetSortParameter

  """Allows the results to be filtered"""
  filter: FacetFilterParameter

  """
  Specifies whether multiple top-level "filter" fields should be combined with a logical AND or OR operation. Defaults to AND.
  """
  filterOperator: LogicalOperator
}

input FacetTranslationInput {
  id: ID
  languageCode: LanguageCode!
  name: String
  customFields: JSON
}

input CreateFacetInput {
  code: String!
  isPrivate: Boolean!
  translations: [FacetTranslationInput!]!
  values: [CreateFacetValueWithFacetInput!]
  customFields: JSON
}

input UpdateFacetInput {
  id: ID!
  isPrivate: Boolean
  code: String
  translations: [FacetTranslationInput!]
  customFields: JSON
}

input FacetValueTranslationInput {
  id: ID
  languageCode: LanguageCode!
  name: String
  customFields: JSON
}

input CreateFacetValueWithFacetInput {
  code: String!
  translations: [FacetValueTranslationInput!]!
}

input CreateFacetValueInput {
  facetId: ID!
  code: String!
  translations: [FacetValueTranslationInput!]!
  customFields: JSON
}

input UpdateFacetValueInput {
  id: ID!
  code: String
  translations: [FacetValueTranslationInput!]
  customFields: JSON
}

input AssignFacetsToChannelInput {
  facetIds: [ID!]!
  channelId: ID!
}

input RemoveFacetsFromChannelInput {
  facetIds: [ID!]!
  channelId: ID!
  force: Boolean
}

type FacetInUseError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
  facetCode: String!
  productCount: Int!
  variantCount: Int!
}

union RemoveFacetFromChannelResult = Facet | FacetInUseError

input UpdateGlobalSettingsInput {
  availableLanguages: [LanguageCode!]
  trackInventory: Boolean
  outOfStockThreshold: Int
  customFields: JSON
}

"""
Returned when the default LanguageCode of a Channel is no longer found in the `availableLanguages`
of the GlobalSettings
"""
type ChannelDefaultLanguageError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
  language: String!
  channelCode: String!
}

union UpdateGlobalSettingsResult = GlobalSettings | ChannelDefaultLanguageError

type GlobalSettings {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  availableLanguages: [LanguageCode!]!
  trackInventory: Boolean!
  outOfStockThreshold: Int!
  serverConfig: ServerConfig!
  customFields: JSON
}

type OrderProcessState {
  name: String!
  to: [String!]!
}

type PermissionDefinition {
  name: String!
  description: String!
  assignable: Boolean!
}

type ServerConfig {
  orderProcess: [OrderProcessState!]!
  permittedAssetTypes: [String!]!
  permissions: [PermissionDefinition!]!
  moneyStrategyPrecision: Int!

  """
  This field is deprecated in v2.2 in favor of the entityCustomFields field,
  which allows custom fields to be defined on user-supplies entities.
  """
  customFieldConfig: CustomFields!
  entityCustomFields: [EntityCustomFields!]!
}

type HistoryEntry implements Node {
  isPublic: Boolean!
  administrator: Administrator
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  type: HistoryEntryType!
  data: JSON!
  customFields: JSON
}

type ImportInfo {
  errors: [String!]
  processed: Int!
  imported: Int!
}

type JobBufferSize {
  bufferId: String!
  size: Int!
}

"""
@description
The state of a Job in the JobQueue

@docsCategory common
"""
enum JobState {
  PENDING
  RUNNING
  COMPLETED
  RETRYING
  FAILED
  CANCELLED
}

input JobListOptions {
  """Skips the first n results, for use in pagination"""
  skip: Int

  """Takes n results, for use in pagination"""
  take: Int

  """Specifies which properties to sort the results by"""
  sort: JobSortParameter

  """Allows the results to be filtered"""
  filter: JobFilterParameter

  """
  Specifies whether multiple top-level "filter" fields should be combined with a logical AND or OR operation. Defaults to AND.
  """
  filterOperator: LogicalOperator
}

type JobList implements PaginatedList {
  items: [Job!]!
  totalItems: Int!
}

type Job implements Node {
  id: ID!
  createdAt: DateTime!
  startedAt: DateTime
  settledAt: DateTime
  queueName: String!
  state: JobState!
  progress: Float!
  data: JSON
  result: JSON
  error: JSON
  isSettled: Boolean!
  duration: Int!
  retries: Int!
  attempts: Int!
}

type JobQueue {
  name: String!
  running: Boolean!
}

type Order implements Node {
  nextStates: [String!]!
  modifications: [OrderModification!]!
  sellerOrders: [Order!]
  aggregateOrder: Order
  aggregateOrderId: ID
  channels: [Channel!]!
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  type: OrderType!

  """
  The date & time that the Order was placed, i.e. the Customer
  completed the checkout and the Order is no longer "active"
  """
  orderPlacedAt: DateTime

  """A unique code for the Order"""
  code: String!
  state: String!

  """
  An order is active as long as the payment process has not been completed
  """
  active: Boolean!
  customer: Customer
  shippingAddress: OrderAddress
  billingAddress: OrderAddress
  lines: [OrderLine!]!

  """
  Surcharges are arbitrary modifications to the Order total which are neither
  ProductVariants nor discounts resulting from applied Promotions. For example,
  one-off discounts based on customer interaction, or surcharges based on payment
  methods.
  """
  surcharges: [Surcharge!]!
  discounts: [Discount!]!

  """An array of all coupon codes applied to the Order"""
  couponCodes: [String!]!

  """
  Promotions applied to the order. Only gets populated after the payment process has completed.
  """
  promotions: [Promotion!]!
  payments: [Payment!]
  fulfillments: [Fulfillment!]
  totalQuantity: Int!

  """
  The subTotal is the total of all OrderLines in the Order. This figure also includes any Order-level
  discounts which have been prorated (proportionally distributed) amongst the items of each OrderLine.
  To get a total of all OrderLines which does not account for prorated discounts, use the
  sum of `OrderLine.discountedLinePrice` values.
  """
  subTotal: Money!

  """Same as subTotal, but inclusive of tax"""
  subTotalWithTax: Money!
  currencyCode: CurrencyCode!
  shippingLines: [ShippingLine!]!
  shipping: Money!
  shippingWithTax: Money!

  """Equal to subTotal plus shipping"""
  total: Money!

  """
  The final payable amount. Equal to subTotalWithTax plus shippingWithTax
  """
  totalWithTax: Money!

  """A summary of the taxes being applied to this Order"""
  taxSummary: [OrderTaxSummary!]!
  history(options: HistoryEntryListOptions): HistoryEntryList!
  customFields: JSON
}

type Fulfillment implements Node {
  nextStates: [String!]!
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  lines: [FulfillmentLine!]!
  summary: [FulfillmentLine!]! @deprecated(reason: "Use the `lines` field instead")
  state: String!
  method: String!
  trackingCode: String
  customFields: JSON
}

type Payment implements Node {
  nextStates: [String!]!
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  method: String!
  amount: Money!
  state: String!
  transactionId: String
  errorMessage: String
  refunds: [Refund!]!
  metadata: JSON
  customFields: JSON
}

type OrderModificationLine {
  orderLine: OrderLine!
  orderLineId: ID!
  quantity: Int!
  modification: OrderModification!
  modificationId: ID!
}

type OrderModification implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  priceChange: Money!
  note: String!
  lines: [OrderModificationLine!]!
  surcharges: [Surcharge!]
  payment: Payment
  refund: Refund
  isSettled: Boolean!
}

input OrderFilterParameter {
  customerLastName: StringOperators
  transactionId: StringOperators
  aggregateOrderId: IDOperators
  id: IDOperators
  createdAt: DateOperators
  updatedAt: DateOperators
  type: StringOperators
  orderPlacedAt: DateOperators
  code: StringOperators
  state: StringOperators
  active: BooleanOperators
  totalQuantity: NumberOperators
  subTotal: NumberOperators
  subTotalWithTax: NumberOperators
  currencyCode: StringOperators
  shipping: NumberOperators
  shippingWithTax: NumberOperators
  total: NumberOperators
  totalWithTax: NumberOperators
  _and: [OrderFilterParameter!]
  _or: [OrderFilterParameter!]
}

input OrderSortParameter {
  customerLastName: SortOrder
  transactionId: SortOrder
  aggregateOrderId: SortOrder
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  orderPlacedAt: SortOrder
  code: SortOrder
  state: SortOrder
  totalQuantity: SortOrder
  subTotal: SortOrder
  subTotalWithTax: SortOrder
  shipping: SortOrder
  shippingWithTax: SortOrder
  total: SortOrder
  totalWithTax: SortOrder
}

input OrderListOptions {
  """Skips the first n results, for use in pagination"""
  skip: Int

  """Takes n results, for use in pagination"""
  take: Int

  """Specifies which properties to sort the results by"""
  sort: OrderSortParameter

  """Allows the results to be filtered"""
  filter: OrderFilterParameter

  """
  Specifies whether multiple top-level "filter" fields should be combined with a logical AND or OR operation. Defaults to AND.
  """
  filterOperator: LogicalOperator
}

input SetOrderCustomerInput {
  orderId: ID!
  customerId: ID!
  note: String
}

input UpdateOrderInput {
  id: ID!
  customFields: JSON
}

input FulfillOrderInput {
  lines: [OrderLineInput!]!
  handler: ConfigurableOperationInput!
}

input CancelOrderInput {
  """The id of the order to be cancelled"""
  orderId: ID!

  """
  Optionally specify which OrderLines to cancel. If not provided, all OrderLines will be cancelled
  """
  lines: [OrderLineInput!]

  """
  Specify whether the shipping charges should also be cancelled. Defaults to false
  """
  cancelShipping: Boolean
  reason: String
}

input RefundOrderInput {
  lines: [OrderLineInput!] @deprecated(reason: "Use the `amount` field instead")
  shipping: Money @deprecated(reason: "Use the `amount` field instead")
  adjustment: Money @deprecated(reason: "Use the `amount` field instead")

  """
  The amount to be refunded to this particular payment. This was introduced in v2.2.0 as the preferred way to specify the refund amount.
  Can be as much as the total amount of the payment minus the sum of all previous refunds.
  """
  amount: Money
  paymentId: ID!
  reason: String
}

input OrderLineInput {
  orderLineId: ID!
  quantity: Int!
}

input SettleRefundInput {
  id: ID!
  transactionId: String!
}

input AddNoteToOrderInput {
  id: ID!
  note: String!
  isPublic: Boolean!
}

input UpdateOrderNoteInput {
  noteId: ID!
  note: String
  isPublic: Boolean
}

input AdministratorPaymentInput {
  paymentMethod: String
  metadata: JSON
}

input AdministratorRefundInput {
  paymentId: ID!
  reason: String

  """
  The amount to be refunded to this particular Payment. This was introduced in
  v2.2.0 as the preferred way to specify the refund amount. The `lines`, `shipping` and `adjustment`
  fields will be removed in a future version.
  """
  amount: Money
}

input ModifyOrderOptions {
  freezePromotions: Boolean
  recalculateShipping: Boolean
}

input UpdateOrderAddressInput {
  fullName: String
  company: String
  streetLine1: String
  streetLine2: String
  city: String
  province: String
  postalCode: String
  countryCode: String
  phoneNumber: String
}

input ModifyOrderInput {
  dryRun: Boolean!
  orderId: ID!
  addItems: [AddItemInput!]
  adjustOrderLines: [OrderLineInput!]
  surcharges: [SurchargeInput!]
  updateShippingAddress: UpdateOrderAddressInput
  updateBillingAddress: UpdateOrderAddressInput
  note: String

  """
  Deprecated in v2.2.0. Use `refunds` instead to allow multiple refunds to be
  applied in the case that multiple payment methods have been used on the order.
  """
  refund: AdministratorRefundInput
  refunds: [AdministratorRefundInput!]
  options: ModifyOrderOptions
  couponCodes: [String!]

  """Added in v2.2"""
  shippingMethodIds: [ID!]
}

input AddItemInput {
  productVariantId: ID!
  quantity: Int!
}

input SurchargeInput {
  description: String!
  sku: String
  price: Money!
  priceIncludesTax: Boolean!
  taxRate: Float
  taxDescription: String
}

input ManualPaymentInput {
  orderId: ID!
  method: String!
  transactionId: String
  metadata: JSON
}

input AddItemToDraftOrderInput {
  productVariantId: ID!
  quantity: Int!
}

input AdjustDraftOrderLineInput {
  orderLineId: ID!
  quantity: Int!
}

"""Returned if the Payment settlement fails"""
type SettlePaymentError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
  paymentErrorMessage: String!
}

"""Returned if the Payment cancellation fails"""
type CancelPaymentError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
  paymentErrorMessage: String!
}

"""Returned if no OrderLines have been specified for the operation"""
type EmptyOrderLineSelectionError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

"""Returned if the specified items are already part of a Fulfillment"""
type ItemsAlreadyFulfilledError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

"""Returned if the specified FulfillmentHandler code is not valid"""
type InvalidFulfillmentHandlerError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

"""
Returned if an error is thrown in a FulfillmentHandler's createFulfillment method
"""
type CreateFulfillmentError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
  fulfillmentHandlerError: String!
}

"""
Returned if attempting to create a Fulfillment when there is insufficient
stockOnHand of a ProductVariant to satisfy the requested quantity.
"""
type InsufficientStockOnHandError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
  productVariantId: ID!
  productVariantName: String!
  stockOnHand: Int!
}

"""Returned if an operation has specified OrderLines from multiple Orders"""
type MultipleOrderError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

"""
Returned if an attempting to cancel lines from an Order which is still active
"""
type CancelActiveOrderError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
  orderState: String!
}

"""
Returned if an attempting to refund a Payment against OrderLines from a different Order
"""
type PaymentOrderMismatchError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

"""
Returned if an attempting to refund an Order which is not in the expected state
"""
type RefundOrderStateError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
  orderState: String!
}

"""
Returned if an attempting to refund an Order but neither items nor shipping refund was specified
"""
type NothingToRefundError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

"""
Returned if an attempting to refund an OrderItem which has already been refunded
"""
type AlreadyRefundedError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
  refundId: ID!
}

"""
Returned if the specified quantity of an OrderLine is greater than the number of items in that line
"""
type QuantityTooGreatError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

"""
Returned if `amount` is greater than the maximum un-refunded amount of the Payment
"""
type RefundAmountError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
  maximumRefundable: Int!
}

"""Returned when there is an error in transitioning the Refund state"""
type RefundStateTransitionError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
  transitionError: String!
  fromState: String!
  toState: String!
}

"""Returned when there is an error in transitioning the Payment state"""
type PaymentStateTransitionError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
  transitionError: String!
  fromState: String!
  toState: String!
}

"""Returned when there is an error in transitioning the Fulfillment state"""
type FulfillmentStateTransitionError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
  transitionError: String!
  fromState: String!
  toState: String!
}

"""
Returned when attempting to modify the contents of an Order that is not in the `Modifying` state.
"""
type OrderModificationStateError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

"""Returned when a call to modifyOrder fails to specify any changes"""
type NoChangesSpecifiedError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

"""
Returned when a call to modifyOrder fails to include a paymentMethod even
though the price has increased as a result of the changes.
"""
type PaymentMethodMissingError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

"""
Returned when a call to modifyOrder fails to include a refundPaymentId even
though the price has decreased as a result of the changes.
"""
type RefundPaymentIdMissingError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

"""
Returned when a call to addManualPaymentToOrder is made but the Order
is not in the required state.
"""
type ManualPaymentStateError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

union TransitionOrderToStateResult = Order | OrderStateTransitionError

union SettlePaymentResult = Payment | SettlePaymentError | PaymentStateTransitionError | OrderStateTransitionError

union CancelPaymentResult = Payment | CancelPaymentError | PaymentStateTransitionError

union AddFulfillmentToOrderResult = Fulfillment | EmptyOrderLineSelectionError | ItemsAlreadyFulfilledError | InsufficientStockOnHandError | InvalidFulfillmentHandlerError | FulfillmentStateTransitionError | CreateFulfillmentError

union CancelOrderResult = Order | EmptyOrderLineSelectionError | QuantityTooGreatError | MultipleOrderError | CancelActiveOrderError | OrderStateTransitionError

union RefundOrderResult = Refund | QuantityTooGreatError | NothingToRefundError | OrderStateTransitionError | MultipleOrderError | PaymentOrderMismatchError | RefundOrderStateError | AlreadyRefundedError | RefundStateTransitionError | RefundAmountError

union SettleRefundResult = Refund | RefundStateTransitionError

union TransitionFulfillmentToStateResult = Fulfillment | FulfillmentStateTransitionError

union TransitionPaymentToStateResult = Payment | PaymentStateTransitionError

union ModifyOrderResult = Order | NoChangesSpecifiedError | OrderModificationStateError | PaymentMethodMissingError | RefundPaymentIdMissingError | OrderLimitError | NegativeQuantityError | InsufficientStockError | CouponCodeExpiredError | CouponCodeInvalidError | CouponCodeLimitError | IneligibleShippingMethodError

union AddManualPaymentToOrderResult = Order | ManualPaymentStateError

union SetCustomerForDraftOrderResult = Order | EmailAddressConflictError

type PaymentMethodList implements PaginatedList {
  items: [PaymentMethod!]!
  totalItems: Int!
}

input PaymentMethodListOptions {
  """Skips the first n results, for use in pagination"""
  skip: Int

  """Takes n results, for use in pagination"""
  take: Int

  """Specifies which properties to sort the results by"""
  sort: PaymentMethodSortParameter

  """Allows the results to be filtered"""
  filter: PaymentMethodFilterParameter

  """
  Specifies whether multiple top-level "filter" fields should be combined with a logical AND or OR operation. Defaults to AND.
  """
  filterOperator: LogicalOperator
}

input PaymentMethodTranslationInput {
  id: ID
  languageCode: LanguageCode!
  name: String
  description: String
  customFields: JSON
}

input CreatePaymentMethodInput {
  code: String!
  enabled: Boolean!
  checker: ConfigurableOperationInput
  handler: ConfigurableOperationInput!
  translations: [PaymentMethodTranslationInput!]!
  customFields: JSON
}

input UpdatePaymentMethodInput {
  id: ID!
  code: String
  enabled: Boolean
  checker: ConfigurableOperationInput
  handler: ConfigurableOperationInput
  translations: [PaymentMethodTranslationInput!]
  customFields: JSON
}

input AssignPaymentMethodsToChannelInput {
  paymentMethodIds: [ID!]!
  channelId: ID!
}

input RemovePaymentMethodsFromChannelInput {
  paymentMethodIds: [ID!]!
  channelId: ID!
}

type Product implements Node {
  channels: [Channel!]!
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  name: String!
  slug: String!
  description: String!
  enabled: Boolean!
  featuredAsset: Asset
  assets: [Asset!]!

  """Returns all ProductVariants"""
  variants: [ProductVariant!]!

  """Returns a paginated, sortable, filterable list of ProductVariants"""
  variantList(options: ProductVariantListOptions): ProductVariantList!
  optionGroups: [ProductOptionGroup!]!
  facetValues: [FacetValue!]!
  translations: [ProductTranslation!]!
  collections: [Collection!]!
  customFields: JSON
}

type ProductVariantPrice {
  currencyCode: CurrencyCode!
  price: Money!
  customFields: JSON
}

type ProductVariant implements Node {
  enabled: Boolean!
  trackInventory: GlobalFlag!
  stockOnHand: Int! @deprecated(reason: "use stockLevels")
  stockAllocated: Int! @deprecated(reason: "use stockLevels")
  outOfStockThreshold: Int!
  useGlobalOutOfStockThreshold: Boolean!
  prices: [ProductVariantPrice!]!
  stockLevels: [StockLevel!]!
  stockMovements(options: StockMovementListOptions): StockMovementList!
  channels: [Channel!]!
  id: ID!
  product: Product!
  productId: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  sku: String!
  name: String!
  featuredAsset: Asset
  assets: [Asset!]!
  price: Money!
  currencyCode: CurrencyCode!
  priceWithTax: Money!
  stockLevel: String!
  taxRateApplied: TaxRate!
  taxCategory: TaxCategory!
  options: [ProductOption!]!
  facetValues: [FacetValue!]!
  translations: [ProductVariantTranslation!]!
  customFields: JSON
}

input ProductOptionListOptions {
  """Skips the first n results, for use in pagination"""
  skip: Int

  """Takes n results, for use in pagination"""
  take: Int

  """Specifies which properties to sort the results by"""
  sort: ProductOptionSortParameter

  """Allows the results to be filtered"""
  filter: ProductOptionFilterParameter

  """
  Specifies whether multiple top-level "filter" fields should be combined with a logical AND or OR operation. Defaults to AND.
  """
  filterOperator: LogicalOperator
}

type ProductOptionList implements PaginatedList {
  totalItems: Int!
  items: [ProductOption!]!
}

input ProductOptionGroupTranslationInput {
  id: ID
  languageCode: LanguageCode!
  name: String
  customFields: JSON
}

input CreateProductOptionGroupInput {
  code: String!
  translations: [ProductOptionGroupTranslationInput!]!
  options: [CreateGroupOptionInput!]!
  customFields: JSON
}

input UpdateProductOptionGroupInput {
  id: ID!
  code: String
  translations: [ProductOptionGroupTranslationInput!]
  customFields: JSON
}

input ProductOptionTranslationInput {
  id: ID
  languageCode: LanguageCode!
  name: String
  customFields: JSON
}

input CreateGroupOptionInput {
  code: String!
  translations: [ProductOptionGroupTranslationInput!]!
}

input CreateProductOptionInput {
  productOptionGroupId: ID!
  code: String!
  translations: [ProductOptionGroupTranslationInput!]!
  customFields: JSON
}

input UpdateProductOptionInput {
  id: ID!
  code: String
  translations: [ProductOptionGroupTranslationInput!]
  customFields: JSON
}

type SearchResult {
  enabled: Boolean!

  """An array of ids of the Channels in which this result appears"""
  channelIds: [ID!]!
  sku: String!
  slug: String!
  productId: ID!
  productName: String!
  productAsset: SearchResultAsset
  productVariantId: ID!
  productVariantName: String!
  productVariantAsset: SearchResultAsset
  price: SearchResultPrice!
  priceWithTax: SearchResultPrice!
  currencyCode: CurrencyCode!
  description: String!
  facetIds: [ID!]!
  facetValueIds: [ID!]!

  """An array of ids of the Collections in which this result appears"""
  collectionIds: [ID!]!

  """
  A relevance score for the result. Differs between database implementations
  """
  score: Float!
  inStock: Boolean!
}

input StockMovementListOptions {
  type: StockMovementType
  skip: Int
  take: Int
}

input ProductListOptions {
  """Skips the first n results, for use in pagination"""
  skip: Int

  """Takes n results, for use in pagination"""
  take: Int

  """Specifies which properties to sort the results by"""
  sort: ProductSortParameter

  """Allows the results to be filtered"""
  filter: ProductFilterParameter

  """
  Specifies whether multiple top-level "filter" fields should be combined with a logical AND or OR operation. Defaults to AND.
  """
  filterOperator: LogicalOperator
}

input ProductFilterParameter {
  facetValueId: IDOperators
  sku: StringOperators
  id: IDOperators
  createdAt: DateOperators
  updatedAt: DateOperators
  languageCode: StringOperators
  name: StringOperators
  slug: StringOperators
  description: StringOperators
  enabled: BooleanOperators
  _and: [ProductFilterParameter!]
  _or: [ProductFilterParameter!]
}

input ProductVariantListOptions {
  """Skips the first n results, for use in pagination"""
  skip: Int

  """Takes n results, for use in pagination"""
  take: Int

  """Specifies which properties to sort the results by"""
  sort: ProductVariantSortParameter

  """Allows the results to be filtered"""
  filter: ProductVariantFilterParameter

  """
  Specifies whether multiple top-level "filter" fields should be combined with a logical AND or OR operation. Defaults to AND.
  """
  filterOperator: LogicalOperator
}

input ProductVariantFilterParameter {
  facetValueId: IDOperators
  enabled: BooleanOperators
  trackInventory: StringOperators
  stockOnHand: NumberOperators
  stockAllocated: NumberOperators
  outOfStockThreshold: NumberOperators
  useGlobalOutOfStockThreshold: BooleanOperators
  id: IDOperators
  productId: IDOperators
  createdAt: DateOperators
  updatedAt: DateOperators
  languageCode: StringOperators
  sku: StringOperators
  name: StringOperators
  price: NumberOperators
  currencyCode: StringOperators
  priceWithTax: NumberOperators
  stockLevel: StringOperators
  _and: [ProductVariantFilterParameter!]
  _or: [ProductVariantFilterParameter!]
}

input ProductTranslationInput {
  id: ID
  languageCode: LanguageCode!
  name: String
  slug: String
  description: String
  customFields: JSON
}

input CreateProductInput {
  featuredAssetId: ID
  enabled: Boolean
  assetIds: [ID!]
  facetValueIds: [ID!]
  translations: [ProductTranslationInput!]!
  customFields: JSON
}

input UpdateProductInput {
  id: ID!
  enabled: Boolean
  featuredAssetId: ID
  assetIds: [ID!]
  facetValueIds: [ID!]
  translations: [ProductTranslationInput!]
  customFields: JSON
}

input ProductVariantTranslationInput {
  id: ID
  languageCode: LanguageCode!
  name: String
  customFields: JSON
}

input CreateProductVariantOptionInput {
  optionGroupId: ID!
  code: String!
  translations: [ProductOptionTranslationInput!]!
}

input StockLevelInput {
  stockLocationId: ID!
  stockOnHand: Int!
}

input CreateProductVariantPriceInput {
  currencyCode: CurrencyCode!
  price: Money!
  customFields: JSON
}

"""
Used to set up update the price of a ProductVariant in a particular Channel.
If the `delete` flag is `true`, the price will be deleted for the given Channel.
"""
input UpdateProductVariantPriceInput {
  currencyCode: CurrencyCode!
  price: Money!
  delete: Boolean
  customFields: JSON
}

input CreateProductVariantInput {
  productId: ID!
  enabled: Boolean
  translations: [ProductVariantTranslationInput!]!
  facetValueIds: [ID!]
  sku: String!
  price: Money
  prices: [CreateProductVariantPriceInput]
  taxCategoryId: ID
  optionIds: [ID!]
  featuredAssetId: ID
  assetIds: [ID!]
  stockOnHand: Int
  stockLevels: [StockLevelInput!]
  outOfStockThreshold: Int
  useGlobalOutOfStockThreshold: Boolean
  trackInventory: GlobalFlag
  customFields: JSON
}

input UpdateProductVariantInput {
  id: ID!
  enabled: Boolean
  translations: [ProductVariantTranslationInput!]
  facetValueIds: [ID!]
  optionIds: [ID!]
  sku: String
  taxCategoryId: ID

  """
  Sets the price for the ProductVariant in the Channel's default currency
  """
  price: Money

  """
  Allows multiple prices to be set for the ProductVariant in different currencies.
  """
  prices: [UpdateProductVariantPriceInput!]
  featuredAssetId: ID
  assetIds: [ID!]
  stockOnHand: Int
  stockLevels: [StockLevelInput!]
  outOfStockThreshold: Int
  useGlobalOutOfStockThreshold: Boolean
  trackInventory: GlobalFlag
  customFields: JSON
}

input AssignProductsToChannelInput {
  productIds: [ID!]!
  channelId: ID!
  priceFactor: Float
}

input RemoveProductsFromChannelInput {
  productIds: [ID!]!
  channelId: ID!
}

input AssignProductVariantsToChannelInput {
  productVariantIds: [ID!]!
  channelId: ID!
  priceFactor: Float
}

input RemoveProductVariantsFromChannelInput {
  productVariantIds: [ID!]!
  channelId: ID!
}

type ProductOptionInUseError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
  optionGroupCode: String!
  productVariantCount: Int!
}

union RemoveOptionGroupFromProductResult = Product | ProductOptionInUseError

input PromotionListOptions {
  """Skips the first n results, for use in pagination"""
  skip: Int

  """Takes n results, for use in pagination"""
  take: Int

  """Specifies which properties to sort the results by"""
  sort: PromotionSortParameter

  """Allows the results to be filtered"""
  filter: PromotionFilterParameter

  """
  Specifies whether multiple top-level "filter" fields should be combined with a logical AND or OR operation. Defaults to AND.
  """
  filterOperator: LogicalOperator
}

input PromotionTranslationInput {
  id: ID
  languageCode: LanguageCode!
  name: String
  description: String
  customFields: JSON
}

input CreatePromotionInput {
  enabled: Boolean!
  startsAt: DateTime
  endsAt: DateTime
  couponCode: String
  perCustomerUsageLimit: Int
  usageLimit: Int
  conditions: [ConfigurableOperationInput!]!
  actions: [ConfigurableOperationInput!]!
  translations: [PromotionTranslationInput!]!
  customFields: JSON
}

input UpdatePromotionInput {
  id: ID!
  enabled: Boolean
  startsAt: DateTime
  endsAt: DateTime
  couponCode: String
  perCustomerUsageLimit: Int
  usageLimit: Int
  conditions: [ConfigurableOperationInput!]
  actions: [ConfigurableOperationInput!]
  translations: [PromotionTranslationInput!]
  customFields: JSON
}

input AssignPromotionsToChannelInput {
  promotionIds: [ID!]!
  channelId: ID!
}

input RemovePromotionsFromChannelInput {
  promotionIds: [ID!]!
  channelId: ID!
}

"""
Returned if a PromotionCondition has neither a couponCode nor any conditions set
"""
type MissingConditionsError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

union CreatePromotionResult = Promotion | MissingConditionsError

union UpdatePromotionResult = Promotion | MissingConditionsError

input ProvinceTranslationInput {
  id: ID
  languageCode: LanguageCode!
  name: String
  customFields: JSON
}

input CreateProvinceInput {
  code: String!
  translations: [ProvinceTranslationInput!]!
  enabled: Boolean!
  customFields: JSON
}

input UpdateProvinceInput {
  id: ID!
  code: String
  translations: [ProvinceTranslationInput!]
  enabled: Boolean
  customFields: JSON
}

input ProvinceListOptions {
  """Skips the first n results, for use in pagination"""
  skip: Int

  """Takes n results, for use in pagination"""
  take: Int

  """Specifies which properties to sort the results by"""
  sort: ProvinceSortParameter

  """Allows the results to be filtered"""
  filter: ProvinceFilterParameter

  """
  Specifies whether multiple top-level "filter" fields should be combined with a logical AND or OR operation. Defaults to AND.
  """
  filterOperator: LogicalOperator
}

input RoleListOptions {
  """Skips the first n results, for use in pagination"""
  skip: Int

  """Takes n results, for use in pagination"""
  take: Int

  """Specifies which properties to sort the results by"""
  sort: RoleSortParameter

  """Allows the results to be filtered"""
  filter: RoleFilterParameter

  """
  Specifies whether multiple top-level "filter" fields should be combined with a logical AND or OR operation. Defaults to AND.
  """
  filterOperator: LogicalOperator
}

input CreateRoleInput {
  code: String!
  description: String!
  permissions: [Permission!]!
  channelIds: [ID!]
}

input UpdateRoleInput {
  id: ID!
  code: String
  description: String
  permissions: [Permission!]
  channelIds: [ID!]
}

input UpdateScheduledTaskInput {
  id: String!
  enabled: Boolean
}

type ScheduledTask {
  id: String!
  description: String!
  schedule: String!
  scheduleDescription: String!
  lastExecutedAt: DateTime
  nextExecutionAt: DateTime
  isRunning: Boolean!
  lastResult: JSON
  enabled: Boolean!
}

type SellerList implements PaginatedList {
  items: [Seller!]!
  totalItems: Int!
}

input SellerListOptions {
  """Skips the first n results, for use in pagination"""
  skip: Int

  """Takes n results, for use in pagination"""
  take: Int

  """Specifies which properties to sort the results by"""
  sort: SellerSortParameter

  """Allows the results to be filtered"""
  filter: SellerFilterParameter

  """
  Specifies whether multiple top-level "filter" fields should be combined with a logical AND or OR operation. Defaults to AND.
  """
  filterOperator: LogicalOperator
}

input CreateSellerInput {
  name: String!
  customFields: JSON
}

input UpdateSellerInput {
  id: ID!
  name: String
  customFields: JSON
}

input SettingsStoreInput {
  key: String!
  value: JSON!
}

type SetSettingsStoreValueResult {
  key: String!
  result: Boolean!
  error: String
}

input ShippingMethodListOptions {
  """Skips the first n results, for use in pagination"""
  skip: Int

  """Takes n results, for use in pagination"""
  take: Int

  """Specifies which properties to sort the results by"""
  sort: ShippingMethodSortParameter

  """Allows the results to be filtered"""
  filter: ShippingMethodFilterParameter

  """
  Specifies whether multiple top-level "filter" fields should be combined with a logical AND or OR operation. Defaults to AND.
  """
  filterOperator: LogicalOperator
}

input ShippingMethodTranslationInput {
  id: ID
  languageCode: LanguageCode!
  name: String
  description: String
  customFields: JSON
}

input CreateShippingMethodInput {
  code: String!
  fulfillmentHandler: String!
  checker: ConfigurableOperationInput!
  calculator: ConfigurableOperationInput!
  translations: [ShippingMethodTranslationInput!]!
  customFields: JSON
}

input UpdateShippingMethodInput {
  id: ID!
  code: String
  fulfillmentHandler: String
  checker: ConfigurableOperationInput
  calculator: ConfigurableOperationInput
  translations: [ShippingMethodTranslationInput!]!
  customFields: JSON
}

input TestShippingMethodInput {
  checker: ConfigurableOperationInput!
  calculator: ConfigurableOperationInput!
  shippingAddress: CreateAddressInput!
  lines: [TestShippingMethodOrderLineInput!]!
}

input TestEligibleShippingMethodsInput {
  shippingAddress: CreateAddressInput!
  lines: [TestShippingMethodOrderLineInput!]!
}

input TestShippingMethodOrderLineInput {
  productVariantId: ID!
  quantity: Int!
}

type TestShippingMethodResult {
  eligible: Boolean!
  quote: TestShippingMethodQuote
}

type TestShippingMethodQuote {
  price: Money!
  priceWithTax: Money!
  metadata: JSON
}

input AssignShippingMethodsToChannelInput {
  shippingMethodIds: [ID!]!
  channelId: ID!
}

input RemoveShippingMethodsFromChannelInput {
  shippingMethodIds: [ID!]!
  channelId: ID!
}

input SlugForEntityInput {
  entityName: String!
  fieldName: String!
  inputValue: String!
  entityId: ID
}

type StockLevel implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  stockLocationId: ID!
  stockOnHand: Int!
  stockAllocated: Int!
  stockLocation: StockLocation!
  customFields: JSON
}

input StockLocationListOptions {
  """Skips the first n results, for use in pagination"""
  skip: Int

  """Takes n results, for use in pagination"""
  take: Int

  """Specifies which properties to sort the results by"""
  sort: StockLocationSortParameter

  """Allows the results to be filtered"""
  filter: StockLocationFilterParameter

  """
  Specifies whether multiple top-level "filter" fields should be combined with a logical AND or OR operation. Defaults to AND.
  """
  filterOperator: LogicalOperator
}

type StockLocationList implements PaginatedList {
  items: [StockLocation!]!
  totalItems: Int!
}

input CreateStockLocationInput {
  name: String!
  description: String
  customFields: JSON
}

input UpdateStockLocationInput {
  id: ID!
  name: String
  description: String
  customFields: JSON
}

input DeleteStockLocationInput {
  id: ID!
  transferToLocationId: ID
}

input AssignStockLocationsToChannelInput {
  stockLocationIds: [ID!]!
  channelId: ID!
}

input RemoveStockLocationsFromChannelInput {
  stockLocationIds: [ID!]!
  channelId: ID!
}

type StockLocation implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  description: String!
  customFields: JSON
}

enum StockMovementType {
  ADJUSTMENT
  ALLOCATION
  RELEASE
  SALE
  CANCELLATION
  RETURN
}

interface StockMovement {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  productVariant: ProductVariant!
  type: StockMovementType!
  quantity: Int!
}

type StockAdjustment implements Node & StockMovement {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  productVariant: ProductVariant!
  type: StockMovementType!
  quantity: Int!
  customFields: JSON
}

type Allocation implements Node & StockMovement {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  productVariant: ProductVariant!
  type: StockMovementType!
  quantity: Int!
  orderLine: OrderLine!
  customFields: JSON
}

type Sale implements Node & StockMovement {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  productVariant: ProductVariant!
  type: StockMovementType!
  quantity: Int!
  customFields: JSON
}

type Cancellation implements Node & StockMovement {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  productVariant: ProductVariant!
  type: StockMovementType!
  quantity: Int!
  orderLine: OrderLine!
  customFields: JSON
}

type Return implements Node & StockMovement {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  productVariant: ProductVariant!
  type: StockMovementType!
  quantity: Int!
  customFields: JSON
}

type Release implements Node & StockMovement {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  productVariant: ProductVariant!
  type: StockMovementType!
  quantity: Int!
  customFields: JSON
}

union StockMovementItem = StockAdjustment | Allocation | Sale | Cancellation | Return | Release

type StockMovementList {
  items: [StockMovementItem!]!
  totalItems: Int!
}

input TagListOptions {
  """Skips the first n results, for use in pagination"""
  skip: Int

  """Takes n results, for use in pagination"""
  take: Int

  """Specifies which properties to sort the results by"""
  sort: TagSortParameter

  """Allows the results to be filtered"""
  filter: TagFilterParameter

  """
  Specifies whether multiple top-level "filter" fields should be combined with a logical AND or OR operation. Defaults to AND.
  """
  filterOperator: LogicalOperator
}

input CreateTagInput {
  value: String!
}

input UpdateTagInput {
  id: ID!
  value: String
}

type TaxCategoryList implements PaginatedList {
  items: [TaxCategory!]!
  totalItems: Int!
}

input TaxCategoryListOptions {
  """Skips the first n results, for use in pagination"""
  skip: Int

  """Takes n results, for use in pagination"""
  take: Int

  """Specifies which properties to sort the results by"""
  sort: TaxCategorySortParameter

  """Allows the results to be filtered"""
  filter: TaxCategoryFilterParameter

  """
  Specifies whether multiple top-level "filter" fields should be combined with a logical AND or OR operation. Defaults to AND.
  """
  filterOperator: LogicalOperator
}

input CreateTaxCategoryInput {
  name: String!
  isDefault: Boolean
  customFields: JSON
}

input UpdateTaxCategoryInput {
  id: ID!
  name: String
  isDefault: Boolean
  customFields: JSON
}

input TaxRateFilterParameter {
  zoneId: IDOperators
  categoryId: IDOperators
  id: IDOperators
  createdAt: DateOperators
  updatedAt: DateOperators
  name: StringOperators
  enabled: BooleanOperators
  value: NumberOperators
  _and: [TaxRateFilterParameter!]
  _or: [TaxRateFilterParameter!]
}

input TaxRateListOptions {
  """Skips the first n results, for use in pagination"""
  skip: Int

  """Takes n results, for use in pagination"""
  take: Int

  """Specifies which properties to sort the results by"""
  sort: TaxRateSortParameter

  """Allows the results to be filtered"""
  filter: TaxRateFilterParameter

  """
  Specifies whether multiple top-level "filter" fields should be combined with a logical AND or OR operation. Defaults to AND.
  """
  filterOperator: LogicalOperator
}

input CreateTaxRateInput {
  name: String!
  enabled: Boolean!
  value: Float!
  categoryId: ID!
  zoneId: ID!
  customerGroupId: ID
  customFields: JSON
}

input UpdateTaxRateInput {
  id: ID!
  name: String
  value: Float
  enabled: Boolean
  categoryId: ID
  zoneId: ID
  customerGroupId: ID
  customFields: JSON
}

type ZoneList implements PaginatedList {
  items: [Zone!]!
  totalItems: Int!
}

input ZoneListOptions {
  """Skips the first n results, for use in pagination"""
  skip: Int

  """Takes n results, for use in pagination"""
  take: Int

  """Specifies which properties to sort the results by"""
  sort: ZoneSortParameter

  """Allows the results to be filtered"""
  filter: ZoneFilterParameter

  """
  Specifies whether multiple top-level "filter" fields should be combined with a logical AND or OR operation. Defaults to AND.
  """
  filterOperator: LogicalOperator
}

input CreateZoneInput {
  name: String!
  memberIds: [ID!]
  customFields: JSON
}

input UpdateZoneInput {
  id: ID!
  name: String
  customFields: JSON
}

type Address implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  fullName: String
  company: String
  streetLine1: String!
  streetLine2: String
  city: String
  province: String
  postalCode: String
  country: Country!
  phoneNumber: String
  defaultShippingAddress: Boolean
  defaultBillingAddress: Boolean
  customFields: JSON
}

type Asset implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  type: AssetType!
  fileSize: Int!
  mimeType: String!
  width: Int!
  height: Int!
  source: String!
  preview: String!
  focalPoint: Coordinate
  tags: [Tag!]!
  customFields: JSON
}

type Coordinate {
  x: Float!
  y: Float!
}

type AssetList implements PaginatedList {
  items: [Asset!]!
  totalItems: Int!
}

enum AssetType {
  IMAGE
  VIDEO
  BINARY
}

type CurrentUser {
  id: ID!
  identifier: String!
  channels: [CurrentUserChannel!]!
}

type CurrentUserChannel {
  id: ID!
  token: String!
  code: String!
  permissions: [Permission!]!
}

type Channel implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  code: String!
  token: String!
  defaultTaxZone: Zone
  defaultShippingZone: Zone
  defaultLanguageCode: LanguageCode!
  availableLanguageCodes: [LanguageCode!]
  currencyCode: CurrencyCode! @deprecated(reason: "Use defaultCurrencyCode instead")
  defaultCurrencyCode: CurrencyCode!
  availableCurrencyCodes: [CurrencyCode!]!

  """Not yet used - will be implemented in a future release."""
  trackInventory: Boolean

  """Not yet used - will be implemented in a future release."""
  outOfStockThreshold: Int
  pricesIncludeTax: Boolean!
  seller: Seller
  customFields: JSON
}

type CollectionBreadcrumb {
  id: ID!
  name: String!
  slug: String!
}

type CollectionTranslation {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  name: String!
  slug: String!
  description: String!
}

type CollectionList implements PaginatedList {
  items: [Collection!]!
  totalItems: Int!
}

enum GlobalFlag {
  TRUE
  FALSE
  INHERIT
}

enum AdjustmentType {
  PROMOTION
  DISTRIBUTED_ORDER_PROMOTION
  OTHER
}

enum DeletionResult {
  """The entity was successfully deleted"""
  DELETED

  """Deletion did not take place, reason given in message"""
  NOT_DELETED
}

"""
@description
Permissions for administrators and customers. Used to control access to
GraphQL resolvers via the {@link Allow} decorator.

## Understanding Permission.Owner

`Permission.Owner` is a special permission which is used in some Vendure resolvers to indicate that that resolver should only
be accessible to the "owner" of that resource.

For example, the Shop API `activeCustomer` query resolver should only return the Customer object for the "owner" of that Customer, i.e.
based on the activeUserId of the current session. As a result, the resolver code looks like this:

@example
```TypeScript
\@Query()
\@Allow(Permission.Owner)
async activeCustomer(\@Ctx() ctx: RequestContext): Promise<Customer | undefined> {
  const userId = ctx.activeUserId;
  if (userId) {
    return this.customerService.findOneByUserId(ctx, userId);
  }
}
```

Here we can see that the "ownership" must be enforced by custom logic inside the resolver. Since "ownership" cannot be defined generally
nor statically encoded at build-time, any resolvers using `Permission.Owner` **must** include logic to enforce that only the owner
of the resource has access. If not, then it is the equivalent of using `Permission.Public`.


@docsCategory common
"""
enum Permission {
  """Authenticated means simply that the user is logged in"""
  Authenticated

  """SuperAdmin has unrestricted access to all operations"""
  SuperAdmin

  """Owner means the user owns this entity, e.g. a Customer's own Order"""
  Owner

  """Public means any unauthenticated user may perform the operation"""
  Public

  """Grants permission to update GlobalSettings"""
  UpdateGlobalSettings

  """Grants permission to create Products, Facets, Assets, Collections"""
  CreateCatalog

  """Grants permission to read Products, Facets, Assets, Collections"""
  ReadCatalog

  """Grants permission to update Products, Facets, Assets, Collections"""
  UpdateCatalog

  """Grants permission to delete Products, Facets, Assets, Collections"""
  DeleteCatalog

  """
  Grants permission to create PaymentMethods, ShippingMethods, TaxCategories, TaxRates, Zones, Countries, System & GlobalSettings
  """
  CreateSettings

  """
  Grants permission to read PaymentMethods, ShippingMethods, TaxCategories, TaxRates, Zones, Countries, System & GlobalSettings
  """
  ReadSettings

  """
  Grants permission to update PaymentMethods, ShippingMethods, TaxCategories, TaxRates, Zones, Countries, System & GlobalSettings
  """
  UpdateSettings

  """
  Grants permission to delete PaymentMethods, ShippingMethods, TaxCategories, TaxRates, Zones, Countries, System & GlobalSettings
  """
  DeleteSettings

  """Grants permission to create Administrator"""
  CreateAdministrator

  """Grants permission to read Administrator"""
  ReadAdministrator

  """Grants permission to update Administrator"""
  UpdateAdministrator

  """Grants permission to delete Administrator"""
  DeleteAdministrator

  """Grants permission to create Asset"""
  CreateAsset

  """Grants permission to read Asset"""
  ReadAsset

  """Grants permission to update Asset"""
  UpdateAsset

  """Grants permission to delete Asset"""
  DeleteAsset

  """Grants permission to create Channel"""
  CreateChannel

  """Grants permission to read Channel"""
  ReadChannel

  """Grants permission to update Channel"""
  UpdateChannel

  """Grants permission to delete Channel"""
  DeleteChannel

  """Grants permission to create Collection"""
  CreateCollection

  """Grants permission to read Collection"""
  ReadCollection

  """Grants permission to update Collection"""
  UpdateCollection

  """Grants permission to delete Collection"""
  DeleteCollection

  """Grants permission to create Country"""
  CreateCountry

  """Grants permission to read Country"""
  ReadCountry

  """Grants permission to update Country"""
  UpdateCountry

  """Grants permission to delete Country"""
  DeleteCountry

  """Grants permission to create Customer"""
  CreateCustomer

  """Grants permission to read Customer"""
  ReadCustomer

  """Grants permission to update Customer"""
  UpdateCustomer

  """Grants permission to delete Customer"""
  DeleteCustomer

  """Grants permission to create CustomerGroup"""
  CreateCustomerGroup

  """Grants permission to read CustomerGroup"""
  ReadCustomerGroup

  """Grants permission to update CustomerGroup"""
  UpdateCustomerGroup

  """Grants permission to delete CustomerGroup"""
  DeleteCustomerGroup

  """Grants permission to create Facet"""
  CreateFacet

  """Grants permission to read Facet"""
  ReadFacet

  """Grants permission to update Facet"""
  UpdateFacet

  """Grants permission to delete Facet"""
  DeleteFacet

  """Grants permission to create Order"""
  CreateOrder

  """Grants permission to read Order"""
  ReadOrder

  """Grants permission to update Order"""
  UpdateOrder

  """Grants permission to delete Order"""
  DeleteOrder

  """Grants permission to create PaymentMethod"""
  CreatePaymentMethod

  """Grants permission to read PaymentMethod"""
  ReadPaymentMethod

  """Grants permission to update PaymentMethod"""
  UpdatePaymentMethod

  """Grants permission to delete PaymentMethod"""
  DeletePaymentMethod

  """Grants permission to create Product"""
  CreateProduct

  """Grants permission to read Product"""
  ReadProduct

  """Grants permission to update Product"""
  UpdateProduct

  """Grants permission to delete Product"""
  DeleteProduct

  """Grants permission to create Promotion"""
  CreatePromotion

  """Grants permission to read Promotion"""
  ReadPromotion

  """Grants permission to update Promotion"""
  UpdatePromotion

  """Grants permission to delete Promotion"""
  DeletePromotion

  """Grants permission to create ShippingMethod"""
  CreateShippingMethod

  """Grants permission to read ShippingMethod"""
  ReadShippingMethod

  """Grants permission to update ShippingMethod"""
  UpdateShippingMethod

  """Grants permission to delete ShippingMethod"""
  DeleteShippingMethod

  """Grants permission to create Tag"""
  CreateTag

  """Grants permission to read Tag"""
  ReadTag

  """Grants permission to update Tag"""
  UpdateTag

  """Grants permission to delete Tag"""
  DeleteTag

  """Grants permission to create TaxCategory"""
  CreateTaxCategory

  """Grants permission to read TaxCategory"""
  ReadTaxCategory

  """Grants permission to update TaxCategory"""
  UpdateTaxCategory

  """Grants permission to delete TaxCategory"""
  DeleteTaxCategory

  """Grants permission to create TaxRate"""
  CreateTaxRate

  """Grants permission to read TaxRate"""
  ReadTaxRate

  """Grants permission to update TaxRate"""
  UpdateTaxRate

  """Grants permission to delete TaxRate"""
  DeleteTaxRate

  """Grants permission to create Seller"""
  CreateSeller

  """Grants permission to read Seller"""
  ReadSeller

  """Grants permission to update Seller"""
  UpdateSeller

  """Grants permission to delete Seller"""
  DeleteSeller

  """Grants permission to create StockLocation"""
  CreateStockLocation

  """Grants permission to read StockLocation"""
  ReadStockLocation

  """Grants permission to update StockLocation"""
  UpdateStockLocation

  """Grants permission to delete StockLocation"""
  DeleteStockLocation

  """Grants permission to create System"""
  CreateSystem

  """Grants permission to read System"""
  ReadSystem

  """Grants permission to update System"""
  UpdateSystem

  """Grants permission to delete System"""
  DeleteSystem

  """Grants permission to create Zone"""
  CreateZone

  """Grants permission to read Zone"""
  ReadZone

  """Grants permission to update Zone"""
  UpdateZone

  """Grants permission to delete Zone"""
  DeleteZone

  """Grants permission to read DashboardGlobalViews"""
  ReadDashboardGlobalViews

  """Grants permission to write DashboardGlobalViews"""
  WriteDashboardGlobalViews
}

enum SortOrder {
  ASC
  DESC
}

enum ErrorCode {
  UNKNOWN_ERROR
  MIME_TYPE_ERROR
  LANGUAGE_NOT_AVAILABLE_ERROR
  DUPLICATE_ENTITY_ERROR
  FACET_IN_USE_ERROR
  CHANNEL_DEFAULT_LANGUAGE_ERROR
  SETTLE_PAYMENT_ERROR
  CANCEL_PAYMENT_ERROR
  EMPTY_ORDER_LINE_SELECTION_ERROR
  ITEMS_ALREADY_FULFILLED_ERROR
  INVALID_FULFILLMENT_HANDLER_ERROR
  CREATE_FULFILLMENT_ERROR
  INSUFFICIENT_STOCK_ON_HAND_ERROR
  MULTIPLE_ORDER_ERROR
  CANCEL_ACTIVE_ORDER_ERROR
  PAYMENT_ORDER_MISMATCH_ERROR
  REFUND_ORDER_STATE_ERROR
  NOTHING_TO_REFUND_ERROR
  ALREADY_REFUNDED_ERROR
  QUANTITY_TOO_GREAT_ERROR
  REFUND_AMOUNT_ERROR
  REFUND_STATE_TRANSITION_ERROR
  PAYMENT_STATE_TRANSITION_ERROR
  FULFILLMENT_STATE_TRANSITION_ERROR
  ORDER_MODIFICATION_STATE_ERROR
  NO_CHANGES_SPECIFIED_ERROR
  PAYMENT_METHOD_MISSING_ERROR
  REFUND_PAYMENT_ID_MISSING_ERROR
  MANUAL_PAYMENT_STATE_ERROR
  PRODUCT_OPTION_IN_USE_ERROR
  MISSING_CONDITIONS_ERROR
  NATIVE_AUTH_STRATEGY_ERROR
  INVALID_CREDENTIALS_ERROR
  ORDER_STATE_TRANSITION_ERROR
  EMAIL_ADDRESS_CONFLICT_ERROR
  GUEST_CHECKOUT_ERROR
  ORDER_LIMIT_ERROR
  NEGATIVE_QUANTITY_ERROR
  INSUFFICIENT_STOCK_ERROR
  COUPON_CODE_INVALID_ERROR
  COUPON_CODE_EXPIRED_ERROR
  COUPON_CODE_LIMIT_ERROR
  ORDER_MODIFICATION_ERROR
  INELIGIBLE_SHIPPING_METHOD_ERROR
  NO_ACTIVE_ORDER_ERROR
  ORDER_INTERCEPTOR_ERROR
}

enum LogicalOperator {
  AND
  OR
}

"""
Returned when attempting an operation that relies on the NativeAuthStrategy, if that strategy is not configured.
"""
type NativeAuthStrategyError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

"""Returned if the user authentication credentials are not valid"""
type InvalidCredentialsError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
  authenticationError: String!
}

"""Returned if there is an error in transitioning the Order state"""
type OrderStateTransitionError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
  transitionError: String!
  fromState: String!
  toState: String!
}

"""
Returned when attempting to create a Customer with an email address already registered to an existing User.
"""
type EmailAddressConflictError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

"""
Returned when attempting to set the Customer on a guest checkout when the configured GuestCheckoutStrategy does not allow it.
"""
type GuestCheckoutError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
  errorDetail: String!
}

"""Returned when the maximum order size limit has been reached."""
type OrderLimitError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
  maxItems: Int!
}

"""Returned when attempting to set a negative OrderLine quantity."""
type NegativeQuantityError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

"""
Returned when attempting to add more items to the Order than are available
"""
type InsufficientStockError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
  quantityAvailable: Int!
  order: Order!
}

"""Returned if the provided coupon code is invalid"""
type CouponCodeInvalidError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
  couponCode: String!
}

"""Returned if the provided coupon code is invalid"""
type CouponCodeExpiredError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
  couponCode: String!
}

"""Returned if the provided coupon code is invalid"""
type CouponCodeLimitError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
  couponCode: String!
  limit: Int!
}

"""
Returned when attempting to modify the contents of an Order that is not in the `AddingItems` state.
"""
type OrderModificationError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

"""
Returned when attempting to set a ShippingMethod for which the Order is not eligible
"""
type IneligibleShippingMethodError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

"""
Returned when invoking a mutation which depends on there being an active Order on the
current session.
"""
type NoActiveOrderError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

"""
Returned when an order operation is rejected by an OrderInterceptor method.
"""
type OrderInterceptorError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
  interceptorError: String!
}

"""
Union type of all possible errors that can occur when adding or removing items from an Order.
"""
union UpdateOrderItemErrorResult = OrderModificationError | OrderLimitError | NegativeQuantityError | InsufficientStockError | OrderInterceptorError

scalar JSON

scalar DateTime

scalar Upload

scalar Money

interface PaginatedList {
  items: [Node!]!
  totalItems: Int!
}

interface Node {
  id: ID!
}

interface ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

type Adjustment {
  adjustmentSource: String!
  type: AdjustmentType!
  description: String!
  amount: Money!
  data: JSON
}

type TaxLine {
  description: String!
  taxRate: Float!
}

type ConfigArg {
  name: String!
  value: String!
}

type ConfigArgDefinition {
  name: String!
  type: String!
  list: Boolean!
  required: Boolean!
  defaultValue: JSON
  label: String
  description: String
  ui: JSON
}

type ConfigurableOperation {
  code: String!
  args: [ConfigArg!]!
}

type ConfigurableOperationDefinition {
  code: String!
  args: [ConfigArgDefinition!]!
  description: String!
}

type DeletionResponse {
  result: DeletionResult!
  message: String
}

input ConfigArgInput {
  name: String!

  """A JSON stringified representation of the actual value"""
  value: String!
}

input ConfigurableOperationInput {
  code: String!
  arguments: [ConfigArgInput!]!
}

"""Operators for filtering on a String field"""
input StringOperators {
  eq: String
  notEq: String
  contains: String
  notContains: String
  in: [String!]
  notIn: [String!]
  regex: String
  isNull: Boolean
}

"""Operators for filtering on an ID field"""
input IDOperators {
  eq: String
  notEq: String
  in: [String!]
  notIn: [String!]
  isNull: Boolean
}

"""Operators for filtering on a Boolean field"""
input BooleanOperators {
  eq: Boolean
  isNull: Boolean
}

input NumberRange {
  start: Float!
  end: Float!
}

"""Operators for filtering on a Int or Float field"""
input NumberOperators {
  eq: Float
  lt: Float
  lte: Float
  gt: Float
  gte: Float
  between: NumberRange
  isNull: Boolean
}

input DateRange {
  start: DateTime!
  end: DateTime!
}

"""Operators for filtering on a DateTime field"""
input DateOperators {
  eq: DateTime
  before: DateTime
  after: DateTime
  between: DateRange
  isNull: Boolean
}

"""Operators for filtering on a list of String fields"""
input StringListOperators {
  inList: String!
}

"""Operators for filtering on a list of Number fields"""
input NumberListOperators {
  inList: Float!
}

"""Operators for filtering on a list of Boolean fields"""
input BooleanListOperators {
  inList: Boolean!
}

"""Operators for filtering on a list of ID fields"""
input IDListOperators {
  inList: ID!
}

"""Operators for filtering on a list of Date fields"""
input DateListOperators {
  inList: DateTime!
}

"""
Used to construct boolean expressions for filtering search results
by FacetValue ID. Examples:

* ID=1 OR ID=2: `{ facetValueFilters: [{ or: [1,2] }] }`
* ID=1 AND ID=2: `{ facetValueFilters: [{ and: 1 }, { and: 2 }] }`
* ID=1 AND (ID=2 OR ID=3): `{ facetValueFilters: [{ and: 1 }, { or: [2,3] }] }`
"""
input FacetValueFilterInput {
  and: ID
  or: [ID!]
}

input SearchInput {
  term: String
  facetValueIds: [ID!] @deprecated(reason: "Use `facetValueFilters` instead")
  facetValueOperator: LogicalOperator @deprecated(reason: "Use `facetValueFilters` instead")
  facetValueFilters: [FacetValueFilterInput!]
  collectionId: ID
  collectionSlug: String
  groupByProduct: Boolean
  take: Int
  skip: Int
  sort: SearchResultSortParameter
  inStock: Boolean
}

input SearchResultSortParameter {
  name: SortOrder
  price: SortOrder
}

input CreateCustomerInput {
  title: String
  firstName: String!
  lastName: String!
  phoneNumber: String
  emailAddress: String!
  customFields: JSON
}

"""
Input used to create an Address.

The countryCode must correspond to a `code` property of a Country that has been defined in the
Vendure server. The `code` property is typically a 2-character ISO code such as "GB", "US", "DE" etc.
If an invalid code is passed, the mutation will fail.
"""
input CreateAddressInput {
  fullName: String
  company: String
  streetLine1: String!
  streetLine2: String
  city: String
  province: String
  postalCode: String
  countryCode: String!
  phoneNumber: String
  defaultShippingAddress: Boolean
  defaultBillingAddress: Boolean
  customFields: JSON
}

"""
Input used to update an Address.

The countryCode must correspond to a `code` property of a Country that has been defined in the
Vendure server. The `code` property is typically a 2-character ISO code such as "GB", "US", "DE" etc.
If an invalid code is passed, the mutation will fail.
"""
input UpdateAddressInput {
  id: ID!
  fullName: String
  company: String
  streetLine1: String
  streetLine2: String
  city: String
  province: String
  postalCode: String
  countryCode: String
  phoneNumber: String
  defaultShippingAddress: Boolean
  defaultBillingAddress: Boolean
  customFields: JSON
}

"""
Indicates that an operation succeeded, where we do not want to return any more specific information.
"""
type Success {
  success: Boolean!
}

type ShippingMethodQuote {
  id: ID!
  price: Money!
  priceWithTax: Money!
  code: String!
  name: String!
  description: String!

  """
  Any optional metadata returned by the ShippingCalculator in the ShippingCalculationResult
  """
  metadata: JSON
  customFields: JSON
}

type PaymentMethodQuote {
  id: ID!
  code: String!
  name: String!
  description: String!
  isEligible: Boolean!
  eligibilityMessage: String
  customFields: JSON
}

union UpdateOrderItemsResult = Order | OrderModificationError | OrderLimitError | NegativeQuantityError | InsufficientStockError | OrderInterceptorError

union RemoveOrderItemsResult = Order | OrderModificationError | OrderInterceptorError

union SetOrderShippingMethodResult = Order | OrderModificationError | IneligibleShippingMethodError | NoActiveOrderError

union ApplyCouponCodeResult = Order | CouponCodeExpiredError | CouponCodeInvalidError | CouponCodeLimitError

"""
@description
ISO 4217 currency code

@docsCategory common
"""
enum CurrencyCode {
  """United Arab Emirates dirham"""
  AED

  """Afghan afghani"""
  AFN

  """Albanian lek"""
  ALL

  """Armenian dram"""
  AMD

  """Netherlands Antillean guilder"""
  ANG

  """Angolan kwanza"""
  AOA

  """Argentine peso"""
  ARS

  """Australian dollar"""
  AUD

  """Aruban florin"""
  AWG

  """Azerbaijani manat"""
  AZN

  """Bosnia and Herzegovina convertible mark"""
  BAM

  """Barbados dollar"""
  BBD

  """Bangladeshi taka"""
  BDT

  """Bulgarian lev"""
  BGN

  """Bahraini dinar"""
  BHD

  """Burundian franc"""
  BIF

  """Bermudian dollar"""
  BMD

  """Brunei dollar"""
  BND

  """Boliviano"""
  BOB

  """Brazilian real"""
  BRL

  """Bahamian dollar"""
  BSD

  """Bhutanese ngultrum"""
  BTN

  """Botswana pula"""
  BWP

  """Belarusian ruble"""
  BYN

  """Belize dollar"""
  BZD

  """Canadian dollar"""
  CAD

  """Congolese franc"""
  CDF

  """Swiss franc"""
  CHF

  """Chilean peso"""
  CLP

  """Renminbi (Chinese) yuan"""
  CNY

  """Colombian peso"""
  COP

  """Costa Rican colon"""
  CRC

  """Cuban convertible peso"""
  CUC

  """Cuban peso"""
  CUP

  """Cape Verde escudo"""
  CVE

  """Czech koruna"""
  CZK

  """Djiboutian franc"""
  DJF

  """Danish krone"""
  DKK

  """Dominican peso"""
  DOP

  """Algerian dinar"""
  DZD

  """Egyptian pound"""
  EGP

  """Eritrean nakfa"""
  ERN

  """Ethiopian birr"""
  ETB

  """Euro"""
  EUR

  """Fiji dollar"""
  FJD

  """Falkland Islands pound"""
  FKP

  """Pound sterling"""
  GBP

  """Georgian lari"""
  GEL

  """Ghanaian cedi"""
  GHS

  """Gibraltar pound"""
  GIP

  """Gambian dalasi"""
  GMD

  """Guinean franc"""
  GNF

  """Guatemalan quetzal"""
  GTQ

  """Guyanese dollar"""
  GYD

  """Hong Kong dollar"""
  HKD

  """Honduran lempira"""
  HNL

  """Croatian kuna"""
  HRK

  """Haitian gourde"""
  HTG

  """Hungarian forint"""
  HUF

  """Indonesian rupiah"""
  IDR

  """Israeli new shekel"""
  ILS

  """Indian rupee"""
  INR

  """Iraqi dinar"""
  IQD

  """Iranian rial"""
  IRR

  """Icelandic krna"""
  ISK

  """Jamaican dollar"""
  JMD

  """Jordanian dinar"""
  JOD

  """Japanese yen"""
  JPY

  """Kenyan shilling"""
  KES

  """Kyrgyzstani som"""
  KGS

  """Cambodian riel"""
  KHR

  """Comoro franc"""
  KMF

  """North Korean won"""
  KPW

  """South Korean won"""
  KRW

  """Kuwaiti dinar"""
  KWD

  """Cayman Islands dollar"""
  KYD

  """Kazakhstani tenge"""
  KZT

  """Lao kip"""
  LAK

  """Lebanese pound"""
  LBP

  """Sri Lankan rupee"""
  LKR

  """Liberian dollar"""
  LRD

  """Lesotho loti"""
  LSL

  """Libyan dinar"""
  LYD

  """Moroccan dirham"""
  MAD

  """Moldovan leu"""
  MDL

  """Malagasy ariary"""
  MGA

  """Macedonian denar"""
  MKD

  """Myanmar kyat"""
  MMK

  """Mongolian tgrg"""
  MNT

  """Macanese pataca"""
  MOP

  """Mauritanian ouguiya"""
  MRU

  """Mauritian rupee"""
  MUR

  """Maldivian rufiyaa"""
  MVR

  """Malawian kwacha"""
  MWK

  """Mexican peso"""
  MXN

  """Malaysian ringgit"""
  MYR

  """Mozambican metical"""
  MZN

  """Namibian dollar"""
  NAD

  """Nigerian naira"""
  NGN

  """Nicaraguan crdoba"""
  NIO

  """Norwegian krone"""
  NOK

  """Nepalese rupee"""
  NPR

  """New Zealand dollar"""
  NZD

  """Omani rial"""
  OMR

  """Panamanian balboa"""
  PAB

  """Peruvian sol"""
  PEN

  """Papua New Guinean kina"""
  PGK

  """Philippine peso"""
  PHP

  """Pakistani rupee"""
  PKR

  """Polish zoty"""
  PLN

  """Paraguayan guaran"""
  PYG

  """Qatari riyal"""
  QAR

  """Romanian leu"""
  RON

  """Serbian dinar"""
  RSD

  """Russian ruble"""
  RUB

  """Rwandan franc"""
  RWF

  """Saudi riyal"""
  SAR

  """Solomon Islands dollar"""
  SBD

  """Seychelles rupee"""
  SCR

  """Sudanese pound"""
  SDG

  """Swedish krona/kronor"""
  SEK

  """Singapore dollar"""
  SGD

  """Saint Helena pound"""
  SHP

  """Sierra Leonean leone"""
  SLL

  """Somali shilling"""
  SOS

  """Surinamese dollar"""
  SRD

  """South Sudanese pound"""
  SSP

  """So Tom and Prncipe dobra"""
  STN

  """Salvadoran coln"""
  SVC

  """Syrian pound"""
  SYP

  """Swazi lilangeni"""
  SZL

  """Thai baht"""
  THB

  """Tajikistani somoni"""
  TJS

  """Turkmenistan manat"""
  TMT

  """Tunisian dinar"""
  TND

  """Tongan paanga"""
  TOP

  """Turkish lira"""
  TRY

  """Trinidad and Tobago dollar"""
  TTD

  """New Taiwan dollar"""
  TWD

  """Tanzanian shilling"""
  TZS

  """Ukrainian hryvnia"""
  UAH

  """Ugandan shilling"""
  UGX

  """United States dollar"""
  USD

  """Uruguayan peso"""
  UYU

  """Uzbekistan som"""
  UZS

  """Venezuelan bolvar soberano"""
  VES

  """Vietnamese ng"""
  VND

  """Vanuatu vatu"""
  VUV

  """Samoan tala"""
  WST

  """CFA franc BEAC"""
  XAF

  """East Caribbean dollar"""
  XCD

  """CFA franc BCEAO"""
  XOF

  """CFP franc (franc Pacifique)"""
  XPF

  """Yemeni rial"""
  YER

  """South African rand"""
  ZAR

  """Zambian kwacha"""
  ZMW

  """Zimbabwean dollar"""
  ZWL
}

interface CustomField {
  name: String!
  type: String!
  list: Boolean!
  label: [LocalizedString!]
  description: [LocalizedString!]
  readonly: Boolean
  internal: Boolean
  nullable: Boolean
  requiresPermission: [Permission!]
  deprecated: Boolean
  deprecationReason: String
  ui: JSON
}

type StringCustomFieldConfig implements CustomField {
  name: String!
  type: String!
  list: Boolean!
  length: Int
  label: [LocalizedString!]
  description: [LocalizedString!]
  readonly: Boolean
  internal: Boolean
  nullable: Boolean
  requiresPermission: [Permission!]
  deprecated: Boolean
  deprecationReason: String
  pattern: String
  options: [StringFieldOption!]
  ui: JSON
}

type StringFieldOption {
  value: String!
  label: [LocalizedString!]
}

type LocaleStringCustomFieldConfig implements CustomField {
  name: String!
  type: String!
  list: Boolean!
  length: Int
  label: [LocalizedString!]
  description: [LocalizedString!]
  readonly: Boolean
  internal: Boolean
  nullable: Boolean
  requiresPermission: [Permission!]
  deprecated: Boolean
  deprecationReason: String
  pattern: String
  ui: JSON
}

type IntCustomFieldConfig implements CustomField {
  name: String!
  type: String!
  list: Boolean!
  label: [LocalizedString!]
  description: [LocalizedString!]
  readonly: Boolean
  internal: Boolean
  nullable: Boolean
  requiresPermission: [Permission!]
  deprecated: Boolean
  deprecationReason: String
  min: Int
  max: Int
  step: Int
  ui: JSON
}

type FloatCustomFieldConfig implements CustomField {
  name: String!
  type: String!
  list: Boolean!
  label: [LocalizedString!]
  description: [LocalizedString!]
  readonly: Boolean
  internal: Boolean
  nullable: Boolean
  requiresPermission: [Permission!]
  deprecated: Boolean
  deprecationReason: String
  min: Float
  max: Float
  step: Float
  ui: JSON
}

type BooleanCustomFieldConfig implements CustomField {
  name: String!
  type: String!
  list: Boolean!
  label: [LocalizedString!]
  description: [LocalizedString!]
  readonly: Boolean
  internal: Boolean
  nullable: Boolean
  requiresPermission: [Permission!]
  deprecated: Boolean
  deprecationReason: String
  ui: JSON
}

"""
Expects the same validation formats as the `<input type="datetime-local">` HTML element.
See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/datetime-local#Additional_attributes
"""
type DateTimeCustomFieldConfig implements CustomField {
  name: String!
  type: String!
  list: Boolean!
  label: [LocalizedString!]
  description: [LocalizedString!]
  readonly: Boolean
  internal: Boolean
  nullable: Boolean
  requiresPermission: [Permission!]
  deprecated: Boolean
  deprecationReason: String
  min: String
  max: String
  step: Int
  ui: JSON
}

type RelationCustomFieldConfig implements CustomField {
  name: String!
  type: String!
  list: Boolean!
  label: [LocalizedString!]
  description: [LocalizedString!]
  readonly: Boolean
  internal: Boolean
  nullable: Boolean
  requiresPermission: [Permission!]
  deprecated: Boolean
  deprecationReason: String
  entity: String!
  scalarFields: [String!]!
  ui: JSON
}

type TextCustomFieldConfig implements CustomField {
  name: String!
  type: String!
  list: Boolean!
  label: [LocalizedString!]
  description: [LocalizedString!]
  readonly: Boolean
  internal: Boolean
  nullable: Boolean
  requiresPermission: [Permission!]
  deprecated: Boolean
  deprecationReason: String
  ui: JSON
}

type LocaleTextCustomFieldConfig implements CustomField {
  name: String!
  type: String!
  list: Boolean!
  label: [LocalizedString!]
  description: [LocalizedString!]
  readonly: Boolean
  internal: Boolean
  nullable: Boolean
  requiresPermission: [Permission!]
  deprecated: Boolean
  deprecationReason: String
  ui: JSON
}

interface StructField {
  name: String!
  type: String!
  list: Boolean
  label: [LocalizedString!]
  description: [LocalizedString!]
  ui: JSON
}

type StringStructFieldConfig implements StructField {
  name: String!
  type: String!
  list: Boolean!
  label: [LocalizedString!]
  description: [LocalizedString!]
  length: Int
  pattern: String
  options: [StringFieldOption!]
  ui: JSON
}

type IntStructFieldConfig implements StructField {
  name: String!
  type: String!
  list: Boolean!
  label: [LocalizedString!]
  description: [LocalizedString!]
  min: Int
  max: Int
  step: Int
  ui: JSON
}

type FloatStructFieldConfig implements StructField {
  name: String!
  type: String!
  list: Boolean!
  label: [LocalizedString!]
  description: [LocalizedString!]
  min: Float
  max: Float
  step: Float
  ui: JSON
}

type BooleanStructFieldConfig implements StructField {
  name: String!
  type: String!
  list: Boolean!
  label: [LocalizedString!]
  description: [LocalizedString!]
  ui: JSON
}

"""
Expects the same validation formats as the `<input type="datetime-local">` HTML element.
See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/datetime-local#Additional_attributes
"""
type DateTimeStructFieldConfig implements StructField {
  name: String!
  type: String!
  list: Boolean!
  label: [LocalizedString!]
  description: [LocalizedString!]
  min: String
  max: String
  step: Int
  ui: JSON
}

type TextStructFieldConfig implements StructField {
  name: String!
  type: String!
  list: Boolean!
  label: [LocalizedString!]
  description: [LocalizedString!]
  ui: JSON
}

union StructFieldConfig = StringStructFieldConfig | IntStructFieldConfig | FloatStructFieldConfig | BooleanStructFieldConfig | DateTimeStructFieldConfig | TextStructFieldConfig

type StructCustomFieldConfig implements CustomField {
  name: String!
  type: String!
  list: Boolean!
  fields: [StructFieldConfig!]!
  label: [LocalizedString!]
  description: [LocalizedString!]
  readonly: Boolean
  internal: Boolean
  nullable: Boolean
  requiresPermission: [Permission!]
  deprecated: Boolean
  deprecationReason: String
  ui: JSON
}

type LocalizedString {
  languageCode: LanguageCode!
  value: String!
}

union CustomFieldConfig = StringCustomFieldConfig | LocaleStringCustomFieldConfig | IntCustomFieldConfig | FloatCustomFieldConfig | BooleanCustomFieldConfig | DateTimeCustomFieldConfig | RelationCustomFieldConfig | TextCustomFieldConfig | LocaleTextCustomFieldConfig | StructCustomFieldConfig

type CustomerGroup implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  customers(options: CustomerListOptions): CustomerList!
  customFields: JSON
}

type CustomerList implements PaginatedList {
  items: [Customer!]!
  totalItems: Int!
}

type FacetValue implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  facet: Facet!
  facetId: ID!
  name: String!
  code: String!
  translations: [FacetValueTranslation!]!
  customFields: JSON
}

type FacetValueTranslation {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  name: String!
}

type FacetTranslation {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  name: String!
}

type FacetList implements PaginatedList {
  items: [Facet!]!
  totalItems: Int!
}

input FacetValueListOptions {
  """Skips the first n results, for use in pagination"""
  skip: Int

  """Takes n results, for use in pagination"""
  take: Int

  """Specifies which properties to sort the results by"""
  sort: FacetValueSortParameter

  """Allows the results to be filtered"""
  filter: FacetValueFilterParameter

  """
  Specifies whether multiple top-level "filter" fields should be combined with a logical AND or OR operation. Defaults to AND.
  """
  filterOperator: LogicalOperator
}

type FacetValueList implements PaginatedList {
  items: [FacetValue!]!
  totalItems: Int!
}

enum HistoryEntryType {
  CUSTOMER_REGISTERED
  CUSTOMER_VERIFIED
  CUSTOMER_DETAIL_UPDATED
  CUSTOMER_ADDED_TO_GROUP
  CUSTOMER_REMOVED_FROM_GROUP
  CUSTOMER_ADDRESS_CREATED
  CUSTOMER_ADDRESS_UPDATED
  CUSTOMER_ADDRESS_DELETED
  CUSTOMER_PASSWORD_UPDATED
  CUSTOMER_PASSWORD_RESET_REQUESTED
  CUSTOMER_PASSWORD_RESET_VERIFIED
  CUSTOMER_EMAIL_UPDATE_REQUESTED
  CUSTOMER_EMAIL_UPDATE_VERIFIED
  CUSTOMER_NOTE
  ORDER_STATE_TRANSITION
  ORDER_PAYMENT_TRANSITION
  ORDER_FULFILLMENT
  ORDER_CANCELLATION
  ORDER_REFUND_TRANSITION
  ORDER_FULFILLMENT_TRANSITION
  ORDER_NOTE
  ORDER_COUPON_APPLIED
  ORDER_COUPON_REMOVED
  ORDER_MODIFIED
  ORDER_CUSTOMER_UPDATED
}

type HistoryEntryList implements PaginatedList {
  items: [HistoryEntry!]!
  totalItems: Int!
}

input HistoryEntryListOptions {
  """Skips the first n results, for use in pagination"""
  skip: Int

  """Takes n results, for use in pagination"""
  take: Int

  """Specifies which properties to sort the results by"""
  sort: HistoryEntrySortParameter

  """Allows the results to be filtered"""
  filter: HistoryEntryFilterParameter

  """
  Specifies whether multiple top-level "filter" fields should be combined with a logical AND or OR operation. Defaults to AND.
  """
  filterOperator: LogicalOperator
}

"""
@description
Languages in the form of a ISO 639-1 language code with optional
region or script modifier (e.g. de_AT). The selection available is based
on the [Unicode CLDR summary list](https://unicode-org.github.io/cldr-staging/charts/37/summary/root.html)
and includes the major spoken languages of the world and any widely-used variants.

@docsCategory common
"""
enum LanguageCode {
  """Afrikaans"""
  af

  """Akan"""
  ak

  """Albanian"""
  sq

  """Amharic"""
  am

  """Arabic"""
  ar

  """Armenian"""
  hy

  """Assamese"""
  as

  """Azerbaijani"""
  az

  """Bambara"""
  bm

  """Bangla"""
  bn

  """Basque"""
  eu

  """Belarusian"""
  be

  """Bosnian"""
  bs

  """Breton"""
  br

  """Bulgarian"""
  bg

  """Burmese"""
  my

  """Catalan"""
  ca

  """Chechen"""
  ce

  """Chinese"""
  zh

  """Simplified Chinese"""
  zh_Hans

  """Traditional Chinese"""
  zh_Hant

  """Church Slavic"""
  cu

  """Cornish"""
  kw

  """Corsican"""
  co

  """Croatian"""
  hr

  """Czech"""
  cs

  """Danish"""
  da

  """Dutch"""
  nl

  """Flemish"""
  nl_BE

  """Dzongkha"""
  dz

  """English"""
  en

  """Australian English"""
  en_AU

  """Canadian English"""
  en_CA

  """British English"""
  en_GB

  """American English"""
  en_US

  """Esperanto"""
  eo

  """Estonian"""
  et

  """Ewe"""
  ee

  """Faroese"""
  fo

  """Finnish"""
  fi

  """French"""
  fr

  """Canadian French"""
  fr_CA

  """Swiss French"""
  fr_CH

  """Fulah"""
  ff

  """Galician"""
  gl

  """Ganda"""
  lg

  """Georgian"""
  ka

  """German"""
  de

  """Austrian German"""
  de_AT

  """Swiss High German"""
  de_CH

  """Greek"""
  el

  """Gujarati"""
  gu

  """Haitian Creole"""
  ht

  """Hausa"""
  ha

  """Hebrew"""
  he

  """Hindi"""
  hi

  """Hungarian"""
  hu

  """Icelandic"""
  is

  """Igbo"""
  ig

  """Indonesian"""
  id

  """Interlingua"""
  ia

  """Irish"""
  ga

  """Italian"""
  it

  """Japanese"""
  ja

  """Javanese"""
  jv

  """Kalaallisut"""
  kl

  """Kannada"""
  kn

  """Kashmiri"""
  ks

  """Kazakh"""
  kk

  """Khmer"""
  km

  """Kikuyu"""
  ki

  """Kinyarwanda"""
  rw

  """Korean"""
  ko

  """Kurdish"""
  ku

  """Kyrgyz"""
  ky

  """Lao"""
  lo

  """Latin"""
  la

  """Latvian"""
  lv

  """Lingala"""
  ln

  """Lithuanian"""
  lt

  """Luba-Katanga"""
  lu

  """Luxembourgish"""
  lb

  """Macedonian"""
  mk

  """Malagasy"""
  mg

  """Malay"""
  ms

  """Malayalam"""
  ml

  """Maltese"""
  mt

  """Manx"""
  gv

  """Maori"""
  mi

  """Marathi"""
  mr

  """Mongolian"""
  mn

  """Nepali"""
  ne

  """North Ndebele"""
  nd

  """Northern Sami"""
  se

  """Norwegian Bokml"""
  nb

  """Norwegian Nynorsk"""
  nn

  """Nyanja"""
  ny

  """Odia"""
  or

  """Oromo"""
  om

  """Ossetic"""
  os

  """Pashto"""
  ps

  """Persian"""
  fa

  """Dari"""
  fa_AF

  """Polish"""
  pl

  """Portuguese"""
  pt

  """Brazilian Portuguese"""
  pt_BR

  """European Portuguese"""
  pt_PT

  """Punjabi"""
  pa

  """Quechua"""
  qu

  """Romanian"""
  ro

  """Moldavian"""
  ro_MD

  """Romansh"""
  rm

  """Rundi"""
  rn

  """Russian"""
  ru

  """Samoan"""
  sm

  """Sango"""
  sg

  """Sanskrit"""
  sa

  """Scottish Gaelic"""
  gd

  """Serbian"""
  sr

  """Shona"""
  sn

  """Sichuan Yi"""
  ii

  """Sindhi"""
  sd

  """Sinhala"""
  si

  """Slovak"""
  sk

  """Slovenian"""
  sl

  """Somali"""
  so

  """Southern Sotho"""
  st

  """Spanish"""
  es

  """European Spanish"""
  es_ES

  """Mexican Spanish"""
  es_MX

  """Sundanese"""
  su

  """Swahili"""
  sw

  """Congo Swahili"""
  sw_CD

  """Swedish"""
  sv

  """Tajik"""
  tg

  """Tamil"""
  ta

  """Tatar"""
  tt

  """Telugu"""
  te

  """Thai"""
  th

  """Tibetan"""
  bo

  """Tigrinya"""
  ti

  """Tongan"""
  to

  """Turkish"""
  tr

  """Turkmen"""
  tk

  """Ukrainian"""
  uk

  """Urdu"""
  ur

  """Uyghur"""
  ug

  """Uzbek"""
  uz

  """Vietnamese"""
  vi

  """Volapk"""
  vo

  """Welsh"""
  cy

  """Western Frisian"""
  fy

  """Wolof"""
  wo

  """Xhosa"""
  xh

  """Yiddish"""
  yi

  """Yoruba"""
  yo

  """Zulu"""
  zu
}

enum OrderType {
  Regular
  Seller
  Aggregate
}

"""
A summary of the taxes being applied to this order, grouped
by taxRate.
"""
type OrderTaxSummary {
  """A description of this tax"""
  description: String!

  """The taxRate as a percentage"""
  taxRate: Float!

  """The total net price of OrderLines to which this taxRate applies"""
  taxBase: Money!

  """The total tax being applied to the Order at this taxRate"""
  taxTotal: Money!
}

type OrderAddress {
  fullName: String
  company: String
  streetLine1: String
  streetLine2: String
  city: String
  province: String
  postalCode: String
  country: String
  countryCode: String
  phoneNumber: String
  customFields: JSON
}

type OrderList implements PaginatedList {
  items: [Order!]!
  totalItems: Int!
}

type ShippingLine {
  id: ID!
  shippingMethod: ShippingMethod!
  price: Money!
  priceWithTax: Money!
  discountedPrice: Money!
  discountedPriceWithTax: Money!
  discounts: [Discount!]!
  customFields: JSON
}

type Discount {
  adjustmentSource: String!
  type: AdjustmentType!
  description: String!
  amount: Money!
  amountWithTax: Money!
}

type OrderLine implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  productVariant: ProductVariant!
  featuredAsset: Asset

  """The price of a single unit, excluding tax and discounts"""
  unitPrice: Money!

  """The price of a single unit, including tax but excluding discounts"""
  unitPriceWithTax: Money!

  """
  Non-zero if the unitPrice has changed since it was initially added to Order
  """
  unitPriceChangeSinceAdded: Money!

  """
  Non-zero if the unitPriceWithTax has changed since it was initially added to Order
  """
  unitPriceWithTaxChangeSinceAdded: Money!

  """
  The price of a single unit including discounts, excluding tax.
  
  If Order-level discounts have been applied, this will not be the
  actual taxable unit price (see `proratedUnitPrice`), but is generally the
  correct price to display to customers to avoid confusion
  about the internal handling of distributed Order-level discounts.
  """
  discountedUnitPrice: Money!

  """The price of a single unit including discounts and tax"""
  discountedUnitPriceWithTax: Money!

  """
  The actual unit price, taking into account both item discounts _and_ prorated (proportionally-distributed)
  Order-level discounts. This value is the true economic value of the OrderItem, and is used in tax
  and refund calculations.
  """
  proratedUnitPrice: Money!

  """The proratedUnitPrice including tax"""
  proratedUnitPriceWithTax: Money!

  """The quantity of items purchased"""
  quantity: Int!

  """The quantity at the time the Order was placed"""
  orderPlacedQuantity: Int!
  taxRate: Float!

  """The total price of the line excluding tax and discounts."""
  linePrice: Money!

  """The total price of the line including tax but excluding discounts."""
  linePriceWithTax: Money!

  """The price of the line including discounts, excluding tax"""
  discountedLinePrice: Money!

  """The price of the line including discounts and tax"""
  discountedLinePriceWithTax: Money!

  """
  The actual line price, taking into account both item discounts _and_ prorated (proportionally-distributed)
  Order-level discounts. This value is the true economic value of the OrderLine, and is used in tax
  and refund calculations.
  """
  proratedLinePrice: Money!

  """The proratedLinePrice including tax"""
  proratedLinePriceWithTax: Money!

  """The total tax on this line"""
  lineTax: Money!
  discounts: [Discount!]!
  taxLines: [TaxLine!]!
  order: Order!
  fulfillmentLines: [FulfillmentLine!]
  customFields: JSON
}

type RefundLine {
  orderLine: OrderLine!
  orderLineId: ID!
  quantity: Int!
  refund: Refund!
  refundId: ID!
}

type Refund implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  items: Money!
  shipping: Money!
  adjustment: Money!
  total: Money!
  method: String
  state: String!
  transactionId: String
  reason: String
  lines: [RefundLine!]!
  paymentId: ID!
  metadata: JSON
  customFields: JSON
}

type FulfillmentLine {
  orderLine: OrderLine!
  orderLineId: ID!
  quantity: Int!
  fulfillment: Fulfillment!
  fulfillmentId: ID!
}

type Surcharge implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  description: String!
  sku: String
  taxLines: [TaxLine!]!
  price: Money!
  priceWithTax: Money!
  taxRate: Float!
}

type PaymentMethod implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  code: String!
  description: String!
  enabled: Boolean!
  checker: ConfigurableOperation
  handler: ConfigurableOperation!
  translations: [PaymentMethodTranslation!]!
  customFields: JSON
}

type PaymentMethodTranslation {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  name: String!
  description: String!
}

type ProductOptionGroup implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  code: String!
  name: String!
  options: [ProductOption!]!
  translations: [ProductOptionGroupTranslation!]!
  customFields: JSON
}

type ProductOptionGroupTranslation {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  name: String!
}

type ProductOption implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  code: String!
  name: String!
  groupId: ID!
  group: ProductOptionGroup!
  translations: [ProductOptionTranslation!]!
  customFields: JSON
}

type ProductOptionTranslation {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  name: String!
}

type SearchReindexResponse {
  success: Boolean!
}

type SearchResponse {
  items: [SearchResult!]!
  totalItems: Int!
  facetValues: [FacetValueResult!]!
  collections: [CollectionResult!]!
}

"""
Which FacetValues are present in the products returned
by the search, and in what quantity.
"""
type FacetValueResult {
  facetValue: FacetValue!
  count: Int!
}

"""
Which Collections are present in the products returned
by the search, and in what quantity.
"""
type CollectionResult {
  collection: Collection!
  count: Int!
}

type SearchResultAsset {
  id: ID!
  preview: String!
  focalPoint: Coordinate
}

"""
The price of a search result product, either as a range or as a single price
"""
union SearchResultPrice = PriceRange | SinglePrice

"""The price value where the result has a single price"""
type SinglePrice {
  value: Money!
}

"""The price range where the result has more than one price"""
type PriceRange {
  min: Money!
  max: Money!
}

type ProductTranslation {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  name: String!
  slug: String!
  description: String!
}

type ProductList implements PaginatedList {
  items: [Product!]!
  totalItems: Int!
}

type ProductVariantList implements PaginatedList {
  items: [ProductVariant!]!
  totalItems: Int!
}

type ProductVariantTranslation {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  name: String!
}

type Promotion implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  startsAt: DateTime
  endsAt: DateTime
  couponCode: String
  perCustomerUsageLimit: Int
  usageLimit: Int
  name: String!
  description: String!
  enabled: Boolean!
  conditions: [ConfigurableOperation!]!
  actions: [ConfigurableOperation!]!
  translations: [PromotionTranslation!]!
  customFields: JSON
}

type PromotionTranslation {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  name: String!
  description: String!
}

type PromotionList implements PaginatedList {
  items: [Promotion!]!
  totalItems: Int!
}

interface Region implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  code: String!
  type: String!
  name: String!
  enabled: Boolean!
  parent: Region
  parentId: ID
  translations: [RegionTranslation!]!
}

type RegionTranslation {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  name: String!
}

"""
A Country of the world which your shop operates in.

The `code` field is typically a 2-character ISO code such as "GB", "US", "DE" etc. This code is used in certain inputs such as
`UpdateAddressInput` and `CreateAddressInput` to specify the country.
"""
type Country implements Region & Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  code: String!
  type: String!
  name: String!
  enabled: Boolean!
  parent: Region
  parentId: ID
  translations: [RegionTranslation!]!
  customFields: JSON
}

type CountryList implements PaginatedList {
  items: [Country!]!
  totalItems: Int!
}

type Province implements Region & Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  code: String!
  type: String!
  name: String!
  enabled: Boolean!
  parent: Region
  parentId: ID
  translations: [RegionTranslation!]!
  customFields: JSON
}

type ProvinceList implements PaginatedList {
  items: [Province!]!
  totalItems: Int!
}

type Role implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  code: String!
  description: String!
  permissions: [Permission!]!
  channels: [Channel!]!
}

type RoleList implements PaginatedList {
  items: [Role!]!
  totalItems: Int!
}

type Seller implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  customFields: JSON
}

type ShippingMethod implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  code: String!
  name: String!
  description: String!
  fulfillmentHandlerCode: String!
  checker: ConfigurableOperation!
  calculator: ConfigurableOperation!
  translations: [ShippingMethodTranslation!]!
  customFields: JSON
}

type ShippingMethodTranslation {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  name: String!
  description: String!
}

type ShippingMethodList implements PaginatedList {
  items: [ShippingMethod!]!
  totalItems: Int!
}

type Tag implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  value: String!
}

type TagList implements PaginatedList {
  items: [Tag!]!
  totalItems: Int!
}

type TaxCategory implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  isDefault: Boolean!
  customFields: JSON
}

type TaxRate implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  enabled: Boolean!
  value: Float!
  category: TaxCategory!
  zone: Zone!
  customerGroup: CustomerGroup
  customFields: JSON
}

type TaxRateList implements PaginatedList {
  items: [TaxRate!]!
  totalItems: Int!
}

type User implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  identifier: String!
  verified: Boolean!
  roles: [Role!]!
  lastLogin: DateTime
  authenticationMethods: [AuthenticationMethod!]!
  customFields: JSON
}

type AuthenticationMethod implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  strategy: String!
}

type Zone implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  members: [Region!]!
  customFields: JSON
}

type DashboardMetricSummary {
  type: DashboardMetricType!
  title: String!
  entries: [DashboardMetricSummaryEntry!]!
}

enum DashboardMetricType {
  OrderCount
  OrderTotal
  AverageOrderValue
}

type DashboardMetricSummaryEntry {
  label: String!
  value: Float!
}

input DashboardMetricSummaryInput {
  types: [DashboardMetricType!]!
  refresh: Boolean
  startDate: DateTime!
  endDate: DateTime!
}

input AdministratorFilterParameter {
  id: IDOperators
  createdAt: DateOperators
  updatedAt: DateOperators
  firstName: StringOperators
  lastName: StringOperators
  emailAddress: StringOperators
  _and: [AdministratorFilterParameter!]
  _or: [AdministratorFilterParameter!]
}

input AdministratorSortParameter {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  firstName: SortOrder
  lastName: SortOrder
  emailAddress: SortOrder
}

input AssetFilterParameter {
  id: IDOperators
  createdAt: DateOperators
  updatedAt: DateOperators
  name: StringOperators
  type: StringOperators
  fileSize: NumberOperators
  mimeType: StringOperators
  width: NumberOperators
  height: NumberOperators
  source: StringOperators
  preview: StringOperators
  _and: [AssetFilterParameter!]
  _or: [AssetFilterParameter!]
}

input AssetSortParameter {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  name: SortOrder
  fileSize: SortOrder
  mimeType: SortOrder
  width: SortOrder
  height: SortOrder
  source: SortOrder
  preview: SortOrder
}

input ChannelFilterParameter {
  id: IDOperators
  createdAt: DateOperators
  updatedAt: DateOperators
  code: StringOperators
  token: StringOperators
  defaultLanguageCode: StringOperators
  currencyCode: StringOperators
  defaultCurrencyCode: StringOperators
  trackInventory: BooleanOperators
  outOfStockThreshold: NumberOperators
  pricesIncludeTax: BooleanOperators
  _and: [ChannelFilterParameter!]
  _or: [ChannelFilterParameter!]
}

input ChannelSortParameter {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  code: SortOrder
  token: SortOrder
  outOfStockThreshold: SortOrder
}

input CollectionFilterParameter {
  isPrivate: BooleanOperators
  inheritFilters: BooleanOperators
  id: IDOperators
  createdAt: DateOperators
  updatedAt: DateOperators
  languageCode: StringOperators
  name: StringOperators
  slug: StringOperators
  position: NumberOperators
  description: StringOperators
  parentId: IDOperators
  _and: [CollectionFilterParameter!]
  _or: [CollectionFilterParameter!]
}

input CollectionSortParameter {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  name: SortOrder
  slug: SortOrder
  position: SortOrder
  description: SortOrder
  parentId: SortOrder
}

input ProductVariantSortParameter {
  stockOnHand: SortOrder
  stockAllocated: SortOrder
  outOfStockThreshold: SortOrder
  id: SortOrder
  productId: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  sku: SortOrder
  name: SortOrder
  price: SortOrder
  priceWithTax: SortOrder
  stockLevel: SortOrder
}

input CountryFilterParameter {
  id: IDOperators
  createdAt: DateOperators
  updatedAt: DateOperators
  languageCode: StringOperators
  code: StringOperators
  type: StringOperators
  name: StringOperators
  enabled: BooleanOperators
  parentId: IDOperators
  _and: [CountryFilterParameter!]
  _or: [CountryFilterParameter!]
}

input CountrySortParameter {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  code: SortOrder
  type: SortOrder
  name: SortOrder
  parentId: SortOrder
}

input CustomerGroupFilterParameter {
  id: IDOperators
  createdAt: DateOperators
  updatedAt: DateOperators
  name: StringOperators
  _and: [CustomerGroupFilterParameter!]
  _or: [CustomerGroupFilterParameter!]
}

input CustomerGroupSortParameter {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  name: SortOrder
}

input CustomerSortParameter {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  title: SortOrder
  firstName: SortOrder
  lastName: SortOrder
  phoneNumber: SortOrder
  emailAddress: SortOrder
}

input FacetFilterParameter {
  isPrivate: BooleanOperators
  id: IDOperators
  createdAt: DateOperators
  updatedAt: DateOperators
  languageCode: StringOperators
  name: StringOperators
  code: StringOperators
  _and: [FacetFilterParameter!]
  _or: [FacetFilterParameter!]
}

input FacetSortParameter {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  name: SortOrder
  code: SortOrder
}

input FacetValueFilterParameter {
  id: IDOperators
  createdAt: DateOperators
  updatedAt: DateOperators
  languageCode: StringOperators
  facetId: IDOperators
  name: StringOperators
  code: StringOperators
  _and: [FacetValueFilterParameter!]
  _or: [FacetValueFilterParameter!]
}

input FacetValueSortParameter {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  facetId: SortOrder
  name: SortOrder
  code: SortOrder
}

input JobFilterParameter {
  id: IDOperators
  createdAt: DateOperators
  startedAt: DateOperators
  settledAt: DateOperators
  queueName: StringOperators
  state: StringOperators
  progress: NumberOperators
  isSettled: BooleanOperators
  duration: NumberOperators
  retries: NumberOperators
  attempts: NumberOperators
  _and: [JobFilterParameter!]
  _or: [JobFilterParameter!]
}

input JobSortParameter {
  id: SortOrder
  createdAt: SortOrder
  startedAt: SortOrder
  settledAt: SortOrder
  queueName: SortOrder
  progress: SortOrder
  duration: SortOrder
  retries: SortOrder
  attempts: SortOrder
}

input PaymentMethodFilterParameter {
  id: IDOperators
  createdAt: DateOperators
  updatedAt: DateOperators
  name: StringOperators
  code: StringOperators
  description: StringOperators
  enabled: BooleanOperators
  _and: [PaymentMethodFilterParameter!]
  _or: [PaymentMethodFilterParameter!]
}

input PaymentMethodSortParameter {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  name: SortOrder
  code: SortOrder
  description: SortOrder
}

input ProductOptionFilterParameter {
  id: IDOperators
  createdAt: DateOperators
  updatedAt: DateOperators
  languageCode: StringOperators
  code: StringOperators
  name: StringOperators
  groupId: IDOperators
  _and: [ProductOptionFilterParameter!]
  _or: [ProductOptionFilterParameter!]
}

input ProductOptionSortParameter {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  code: SortOrder
  name: SortOrder
  groupId: SortOrder
}

input ProductSortParameter {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  name: SortOrder
  slug: SortOrder
  description: SortOrder
}

input PromotionFilterParameter {
  id: IDOperators
  createdAt: DateOperators
  updatedAt: DateOperators
  startsAt: DateOperators
  endsAt: DateOperators
  couponCode: StringOperators
  perCustomerUsageLimit: NumberOperators
  usageLimit: NumberOperators
  name: StringOperators
  description: StringOperators
  enabled: BooleanOperators
  _and: [PromotionFilterParameter!]
  _or: [PromotionFilterParameter!]
}

input PromotionSortParameter {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  startsAt: SortOrder
  endsAt: SortOrder
  couponCode: SortOrder
  perCustomerUsageLimit: SortOrder
  usageLimit: SortOrder
  name: SortOrder
  description: SortOrder
}

input ProvinceFilterParameter {
  id: IDOperators
  createdAt: DateOperators
  updatedAt: DateOperators
  languageCode: StringOperators
  code: StringOperators
  type: StringOperators
  name: StringOperators
  enabled: BooleanOperators
  parentId: IDOperators
  _and: [ProvinceFilterParameter!]
  _or: [ProvinceFilterParameter!]
}

input ProvinceSortParameter {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  code: SortOrder
  type: SortOrder
  name: SortOrder
  parentId: SortOrder
}

input RoleFilterParameter {
  id: IDOperators
  createdAt: DateOperators
  updatedAt: DateOperators
  code: StringOperators
  description: StringOperators
  _and: [RoleFilterParameter!]
  _or: [RoleFilterParameter!]
}

input RoleSortParameter {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  code: SortOrder
  description: SortOrder
}

input SellerFilterParameter {
  id: IDOperators
  createdAt: DateOperators
  updatedAt: DateOperators
  name: StringOperators
  _and: [SellerFilterParameter!]
  _or: [SellerFilterParameter!]
}

input SellerSortParameter {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  name: SortOrder
}

input ShippingMethodFilterParameter {
  id: IDOperators
  createdAt: DateOperators
  updatedAt: DateOperators
  languageCode: StringOperators
  code: StringOperators
  name: StringOperators
  description: StringOperators
  fulfillmentHandlerCode: StringOperators
  _and: [ShippingMethodFilterParameter!]
  _or: [ShippingMethodFilterParameter!]
}

input ShippingMethodSortParameter {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  code: SortOrder
  name: SortOrder
  description: SortOrder
  fulfillmentHandlerCode: SortOrder
}

input StockLocationFilterParameter {
  id: IDOperators
  createdAt: DateOperators
  updatedAt: DateOperators
  name: StringOperators
  description: StringOperators
  _and: [StockLocationFilterParameter!]
  _or: [StockLocationFilterParameter!]
}

input StockLocationSortParameter {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  name: SortOrder
  description: SortOrder
}

input TagFilterParameter {
  id: IDOperators
  createdAt: DateOperators
  updatedAt: DateOperators
  value: StringOperators
  _and: [TagFilterParameter!]
  _or: [TagFilterParameter!]
}

input TagSortParameter {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  value: SortOrder
}

input TaxCategoryFilterParameter {
  id: IDOperators
  createdAt: DateOperators
  updatedAt: DateOperators
  name: StringOperators
  isDefault: BooleanOperators
  _and: [TaxCategoryFilterParameter!]
  _or: [TaxCategoryFilterParameter!]
}

input TaxCategorySortParameter {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  name: SortOrder
}

input TaxRateSortParameter {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  name: SortOrder
  value: SortOrder
}

input ZoneFilterParameter {
  id: IDOperators
  createdAt: DateOperators
  updatedAt: DateOperators
  name: StringOperators
  _and: [ZoneFilterParameter!]
  _or: [ZoneFilterParameter!]
}

input ZoneSortParameter {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  name: SortOrder
}

input HistoryEntryFilterParameter {
  isPublic: BooleanOperators
  id: IDOperators
  createdAt: DateOperators
  updatedAt: DateOperators
  type: StringOperators
  _and: [HistoryEntryFilterParameter!]
  _or: [HistoryEntryFilterParameter!]
}

input HistoryEntrySortParameter {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
}

input NativeAuthInput {
  username: String!
  password: String!
}

"""
This type is deprecated in v2.2 in favor of the EntityCustomFields type,
which allows custom fields to be defined on user-supplied entities.
"""
type CustomFields {
  Address: [CustomFieldConfig!]!
  Administrator: [CustomFieldConfig!]!
  Asset: [CustomFieldConfig!]!
  Channel: [CustomFieldConfig!]!
  Collection: [CustomFieldConfig!]!
  Customer: [CustomFieldConfig!]!
  CustomerGroup: [CustomFieldConfig!]!
  Facet: [CustomFieldConfig!]!
  FacetValue: [CustomFieldConfig!]!
  Fulfillment: [CustomFieldConfig!]!
  GlobalSettings: [CustomFieldConfig!]!
  HistoryEntry: [CustomFieldConfig!]!
  Order: [CustomFieldConfig!]!
  OrderLine: [CustomFieldConfig!]!
  Payment: [CustomFieldConfig!]!
  PaymentMethod: [CustomFieldConfig!]!
  Product: [CustomFieldConfig!]!
  ProductOption: [CustomFieldConfig!]!
  ProductOptionGroup: [CustomFieldConfig!]!
  ProductVariant: [CustomFieldConfig!]!
  ProductVariantPrice: [CustomFieldConfig!]!
  Promotion: [CustomFieldConfig!]!
  Refund: [CustomFieldConfig!]!
  Region: [CustomFieldConfig!]!
  Seller: [CustomFieldConfig!]!
  Session: [CustomFieldConfig!]!
  ShippingLine: [CustomFieldConfig!]!
  ShippingMethod: [CustomFieldConfig!]!
  StockLevel: [CustomFieldConfig!]!
  StockLocation: [CustomFieldConfig!]!
  StockMovement: [CustomFieldConfig!]!
  TaxCategory: [CustomFieldConfig!]!
  TaxRate: [CustomFieldConfig!]!
  User: [CustomFieldConfig!]!
  Zone: [CustomFieldConfig!]!
}

type EntityCustomFields {
  entityName: String!
  customFields: [CustomFieldConfig!]!
}